{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Under construction This page is under construction.","title":"Home"},{"location":"api-reference/","text":"API Reference \u00b6 Welcome to the API Reference! This is where you can find more technical documentation about what the Fusion library provides. This isn't a beginner's guide. For a guided experience, try the tutorials! Navigation \u00b6 Using the sidebar on the left, you can find API members grouped by category. Alternatively, you can search for APIs using the search box at the top of the page. Commonly Used \u00b6 General \u00b6 Errors State Instances Animation State \u00b6 Computed ForKeys ForPairs ForValues Observer Value Instances \u00b6 Hydrate New Animation \u00b6 Spring Tween","title":"Home"},{"location":"api-reference/#api-reference","text":"Welcome to the API Reference! This is where you can find more technical documentation about what the Fusion library provides. This isn't a beginner's guide. For a guided experience, try the tutorials!","title":"API Reference"},{"location":"api-reference/#navigation","text":"Using the sidebar on the left, you can find API members grouped by category. Alternatively, you can search for APIs using the search box at the top of the page.","title":"Navigation"},{"location":"api-reference/#commonly-used","text":"","title":"Commonly Used"},{"location":"api-reference/#general","text":"Errors State Instances Animation","title":"General"},{"location":"api-reference/#state","text":"Computed ForKeys ForPairs ForValues Observer Value","title":"State"},{"location":"api-reference/#instances","text":"Hydrate New","title":"Instances"},{"location":"api-reference/#animation","text":"Spring Tween","title":"Animation"},{"location":"api-reference/animation/","text":"Fusion Animation \u00b6 Utilities for adding transitions and animations to state objects. Types \u00b6 Animatable State Objects \u00b6 Spring Tween","title":"Index"},{"location":"api-reference/animation/#animation","text":"Utilities for adding transitions and animations to state objects.","title":"\n    Animation"},{"location":"api-reference/animation/#types","text":"Animatable","title":"Types"},{"location":"api-reference/animation/#state-objects","text":"Spring Tween","title":"State Objects"},{"location":"api-reference/animation/animatable/","text":"Fusion Animation Animatable type since v0.1 \u00b6 Represents types that can be animated component-wise. If a data type can reasonably be represented as a fixed-length array of numbers, then it is animatable. Any data type present in this type can be animated by Fusion. number | CFrame | Color3 | ColorSequenceKeypoint | DateTime | NumberRange | NumberSequenceKeypoint | PhysicalProperties | Ray | Rect | Region3 | Region3int16 | UDim | UDim2 | Vector2 | Vector2int16 | Vector3 | Vector3int16 Example Usage \u00b6 local DEFAULT_TWEEN = TweenInfo . new ( 0.25 , Enum . EasingStyle . Quint ) local function withDefaultTween ( target : StateObject < Animatable > ) return Tween ( target , DEFAULT_TWEEN ) end Animatability \u00b6 Tween and Spring work by animating the individual components of whatever data they're working with. For example, if you tween a Vector3, the X, Y and Z components will have the tween individually applied to each. This is a very flexible definition of animatability, but it does not cover all data types. For example, it still doesn't make sense to animate a string, a boolean, or nil. By default, Tween and Spring will just snap to the goal value if you try to smoothly animate something that is not animatable. However, if you want to try and prevent the use of non-animatable types statically, you can use this type definition in your own code.","title":"Animatable"},{"location":"api-reference/animation/animatable/#animatable-type-since-v01","text":"Represents types that can be animated component-wise. If a data type can reasonably be represented as a fixed-length array of numbers, then it is animatable. Any data type present in this type can be animated by Fusion. number | CFrame | Color3 | ColorSequenceKeypoint | DateTime | NumberRange | NumberSequenceKeypoint | PhysicalProperties | Ray | Rect | Region3 | Region3int16 | UDim | UDim2 | Vector2 | Vector2int16 | Vector3 | Vector3int16","title":"\n    Animatable\n    \n        type\n        since v0.1\n    "},{"location":"api-reference/animation/animatable/#example-usage","text":"local DEFAULT_TWEEN = TweenInfo . new ( 0.25 , Enum . EasingStyle . Quint ) local function withDefaultTween ( target : StateObject < Animatable > ) return Tween ( target , DEFAULT_TWEEN ) end","title":"Example Usage"},{"location":"api-reference/animation/animatable/#animatability","text":"Tween and Spring work by animating the individual components of whatever data they're working with. For example, if you tween a Vector3, the X, Y and Z components will have the tween individually applied to each. This is a very flexible definition of animatability, but it does not cover all data types. For example, it still doesn't make sense to animate a string, a boolean, or nil. By default, Tween and Spring will just snap to the goal value if you try to smoothly animate something that is not animatable. However, if you want to try and prevent the use of non-animatable types statically, you can use this type definition in your own code.","title":"Animatability"},{"location":"api-reference/animation/spring/","text":"Fusion Animation Spring state object since v0.1 \u00b6 Follows the value of another state object, as if linked by a damped spring. If the state object is not animatable , the spring will just snap to the goal value. ( goal : StateObject < T > , speed : CanBeState < number > ? , damping : CanBeState < number > ? ) -> Spring < T > Parameters \u00b6 goal - The state object whose value should be followed. speed - Scales the time it takes for the spring to move (but does not directly correlate to a duration). Defaults to 10 . damping - Affects the friction/damping which the spring experiences. 0 represents no friction, and 1 is just enough friction to reach the goal without overshooting or oscillating. Defaults to 1 . Methods \u00b6 since v0.1 Spring:get() \u00b6 Returns the current value stored in the state object. If dependencies are being captured (e.g. inside a computed callback), this state object will also be added as a dependency. ( asDependency : boolean ? ) -> T Parameters \u00b6 asDependency - If this is explicitly set to false, no dependencies will be captured. since v0.2 Spring:setPosition() \u00b6 Instantaneously moves the spring to a new position. This does not affect the velocity of the spring. If the given value doesn't have the same type as the spring's current value, an error will be thrown. ( newPosition : T ) -> () Parameters \u00b6 newPosition - The value the spring's position should jump to. since v0.2 Spring:setVelocity() \u00b6 Overwrites the velocity of this spring. This does not have an immediate effect on the position of the spring. If the given value doesn't have the same type as the spring's current value, an error will be thrown. ( newVelocity : T ) -> () Parameters \u00b6 newVelocity - The value the spring's velocity should jump to. since v0.2 Spring:addVelocity() \u00b6 Adds to the velocity of this spring. This does not have an immediate effect on the position of the spring. If the given value doesn't have the same type as the spring's current value, an error will be thrown. ( deltaVelocity : T ) -> () Parameters \u00b6 deltaVelocity - The velocity to add to the spring. Example Usage \u00b6 local position = Value ( UDim2 . fromOffset ( 25 , 50 )) local smoothPosition = Spring ( position , 25 , 0.6 ) local ui = New \"Frame\" { Parent = PlayerGui . ScreenGui , Position = smoothPosition } while true do task . wait ( 5 ) -- apply an impulse smoothPosition : addVelocity ( UDim2 . fromOffset ( - 10 , 10 )) end","title":"Spring"},{"location":"api-reference/animation/spring/#spring-state-object-since-v01","text":"Follows the value of another state object, as if linked by a damped spring. If the state object is not animatable , the spring will just snap to the goal value. ( goal : StateObject < T > , speed : CanBeState < number > ? , damping : CanBeState < number > ? ) -> Spring < T >","title":"\n    Spring\n    \n        state object\n        since v0.1\n    "},{"location":"api-reference/animation/spring/#parameters","text":"goal - The state object whose value should be followed. speed - Scales the time it takes for the spring to move (but does not directly correlate to a duration). Defaults to 10 . damping - Affects the friction/damping which the spring experiences. 0 represents no friction, and 1 is just enough friction to reach the goal without overshooting or oscillating. Defaults to 1 .","title":"Parameters"},{"location":"api-reference/animation/spring/#methods","text":"since v0.1","title":"Methods"},{"location":"api-reference/animation/spring/#springget","text":"Returns the current value stored in the state object. If dependencies are being captured (e.g. inside a computed callback), this state object will also be added as a dependency. ( asDependency : boolean ? ) -> T","title":" Spring:get()"},{"location":"api-reference/animation/spring/#parameters_1","text":"asDependency - If this is explicitly set to false, no dependencies will be captured. since v0.2","title":"Parameters"},{"location":"api-reference/animation/spring/#springsetposition","text":"Instantaneously moves the spring to a new position. This does not affect the velocity of the spring. If the given value doesn't have the same type as the spring's current value, an error will be thrown. ( newPosition : T ) -> ()","title":" Spring:setPosition()"},{"location":"api-reference/animation/spring/#parameters_2","text":"newPosition - The value the spring's position should jump to. since v0.2","title":"Parameters"},{"location":"api-reference/animation/spring/#springsetvelocity","text":"Overwrites the velocity of this spring. This does not have an immediate effect on the position of the spring. If the given value doesn't have the same type as the spring's current value, an error will be thrown. ( newVelocity : T ) -> ()","title":" Spring:setVelocity()"},{"location":"api-reference/animation/spring/#parameters_3","text":"newVelocity - The value the spring's velocity should jump to. since v0.2","title":"Parameters"},{"location":"api-reference/animation/spring/#springaddvelocity","text":"Adds to the velocity of this spring. This does not have an immediate effect on the position of the spring. If the given value doesn't have the same type as the spring's current value, an error will be thrown. ( deltaVelocity : T ) -> ()","title":" Spring:addVelocity()"},{"location":"api-reference/animation/spring/#parameters_4","text":"deltaVelocity - The velocity to add to the spring.","title":"Parameters"},{"location":"api-reference/animation/spring/#example-usage","text":"local position = Value ( UDim2 . fromOffset ( 25 , 50 )) local smoothPosition = Spring ( position , 25 , 0.6 ) local ui = New \"Frame\" { Parent = PlayerGui . ScreenGui , Position = smoothPosition } while true do task . wait ( 5 ) -- apply an impulse smoothPosition : addVelocity ( UDim2 . fromOffset ( - 10 , 10 )) end","title":"Example Usage"},{"location":"api-reference/animation/tween/","text":"Fusion Animation Tween state object since v0.1 \u00b6 Follows the value of another state object, by tweening towards it. If the state object is not animatable , the tween will just snap to the goal value. ( goal : StateObject < T > , tweenInfo : CanBeState < TweenInfo > ? ) -> Tween < T > Parameters \u00b6 goal - The state object whose value should be followed. tweenInfo - The style of tween to use when moving to the goal. Defaults to TweenInfo.new() . Methods \u00b6 since v0.1 Tween:get() \u00b6 Returns the current value stored in the state object. If dependencies are being captured (e.g. inside a computed callback), this state object will also be added as a dependency. ( asDependency : boolean ? ) -> T Parameters \u00b6 asDependency - If this is explicitly set to false, no dependencies will be captured. Example Usage \u00b6 local position = Value ( UDim2 . fromOffset ( 25 , 50 )) local smoothPosition = Spring ( position , 25 , 0.6 ) local ui = New \"Frame\" { Parent = PlayerGui . ScreenGui , Position = smoothPosition } while true do task . wait ( 5 ) -- apply an impulse smoothPosition : addVelocity ( UDim2 . fromOffset ( - 10 , 10 )) end","title":"Tween"},{"location":"api-reference/animation/tween/#tween-state-object-since-v01","text":"Follows the value of another state object, by tweening towards it. If the state object is not animatable , the tween will just snap to the goal value. ( goal : StateObject < T > , tweenInfo : CanBeState < TweenInfo > ? ) -> Tween < T >","title":"\n    Tween\n    \n        state object\n        since v0.1\n    "},{"location":"api-reference/animation/tween/#parameters","text":"goal - The state object whose value should be followed. tweenInfo - The style of tween to use when moving to the goal. Defaults to TweenInfo.new() .","title":"Parameters"},{"location":"api-reference/animation/tween/#methods","text":"since v0.1","title":"Methods"},{"location":"api-reference/animation/tween/#tweenget","text":"Returns the current value stored in the state object. If dependencies are being captured (e.g. inside a computed callback), this state object will also be added as a dependency. ( asDependency : boolean ? ) -> T","title":" Tween:get()"},{"location":"api-reference/animation/tween/#parameters_1","text":"asDependency - If this is explicitly set to false, no dependencies will be captured.","title":"Parameters"},{"location":"api-reference/animation/tween/#example-usage","text":"local position = Value ( UDim2 . fromOffset ( 25 , 50 )) local smoothPosition = Spring ( position , 25 , 0.6 ) local ui = New \"Frame\" { Parent = PlayerGui . ScreenGui , Position = smoothPosition } while true do task . wait ( 5 ) -- apply an impulse smoothPosition : addVelocity ( UDim2 . fromOffset ( - 10 , 10 )) end","title":"Example Usage"},{"location":"api-reference/errors/","text":"Fusion Errors \u00b6 Whenever Fusion outputs any errors or messages to the console, it will have a short error ID at the end. This is used to uniquely identify what kind of error or message you're seeing. Use the search box below to paste in or type an error ID, and it will scroll to the details for you. since v0.2 applyPropsNilRef \u00b6 `applyInstanceProps` got a nil ref! (this is an internal issue) Internally in Fusion, the New and Hydrate functions call a helper function, applyInstanceProps , to do the work of binding properties and applying special keys. If that function is given nil instead of an instance, this error is thrown. This could occur if internal code accidentally destroys an instance via garbage collection, which could have large implications for projects using Fusion. The error and reproduction steps should be reported as soon as possible. since v0.1 cannotAssignProperty \u00b6 The class type 'Foo' has no assignable property 'Bar'. This message shows if you try to assign a non-existent or locked property using the New or Hydrate functions: local folder = New \"Folder\" { DataCost = 12345 , ThisPropertyDoesntExist = \"Example\" } Tip Different scripts may have different privileges - for example, plugins will be allowed more privileges than in-game scripts. Make sure you have the necessary privileges to assign to your properties! since v0.1 cannotConnectChange \u00b6 The Frame class doesn't have a property called 'Foo'. This message shows if you try to connect a handler to a non-existent property change event when using the New or Hydrate functions: local textBox = New \"TextBox\" { [ OnChange \"ThisPropertyDoesntExist\" ] = function () ... end ) } since v0.1 cannotConnectEvent \u00b6 The Frame class doesn't have an event called 'Foo'. This message shows if you try to connect a handler to a non-existent event when using the New or Hydrate functions: local button = New \"TextButton\" { [ OnEvent \"ThisEventDoesntExist\" ] = function () ... end ) } since v0.1 cannotCreateClass \u00b6 Can't create a new instance of class 'Foo'. This message shows when using the New function with an invalid class type: local instance = New \"ThisClassTypeIsInvalid\" { ... } since v0.1 computedCallbackError \u00b6 Computed callback error: attempt to index a nil value This message shows when the callback of a computed object encounters an error: local example = Computed ( function () local badMath = 2 + \"fish\" end ) since v0.2 duplicatePropertyKey \u00b6 Can't assign to 'Name' twice. This message shows if you try to declare the same property more than once when using the New or Hydrate functions: local button = New \"TextButton\" { Name = \"Joseph\" } Hydrate ( button ) { Name = \"Simon\" -- ambiguous! Is the name supposed to be Joseph or Simon? } since v0.2 invalidChangeHandler \u00b6 The change handler for the 'Text' property must be a function. This message shows if you try to give OnChange something other than a function: local input = New \"TextBox\" { [ OnChange \"Text\" ] = \"lemons\" } since v0.2 invalidEventHandler \u00b6 The handler for the 'Activated' event must be a function. This message shows if you try to give OnEvent something other than a function: local button = New \"TextButton\" { [ OnEvent \"Activated\" ] = \"limes\" } since v0.2 invalidPropertyType \u00b6 'Frame.Size' expected a 'UDim2' type, but got a 'Color3' type. When using the New or Hydrate functions, you can pass values to properties. If you pass a value of the wrong type for that property, and Roblox can't convert it, this error will be shown. local ui = New \"Frame\" { Size = Computed ( function () return Color3 . new ( 1 , 0 , 0 ) end ) } since v0.2 invalidRefType \u00b6 Instance refs must be Value objects. The Ref key expects a Value object so it can store the instance reference inside of it. This error is thrown if it receives something that is not a Value object. local thing = New \"Part\" { [ Ref ] = 2 } since v0.2 invalidOutType \u00b6 [Out] properties must be given Value objects. Keys made using Out expect a Value object so they can store property values inside of it. This error is thrown if it receives something that is not a Value object. local thing = New \"Part\" { [ Out \"Color\" ] = true } since v0.2 invalidOutProperty \u00b6 The Part class doesn't have a property called 'Flobulator'. This error is thrown if a property name is used with Out which doesn't exist or can't be accessed. local value = Value () local thing = New \"Part\" { [ Out \"Flobulator\" ] = value } since v0.1 invalidSpringDamping \u00b6 The damping ratio for a spring must be >= 0. (damping was -0.50) This message shows if you try to provide a damping ratio to a spring which is less than 0: local speed = 10 local damping = - 12345 local spring = Spring ( state , speed , damping ) Damping ratio must always be between 0 and infinity for a spring to be physically simulatable. since v0.1 invalidSpringSpeed \u00b6 The speed of a spring must be >= 0. (speed was -2.00) This message shows if you try to provide a speed to a spring which is less than 0: local speed = - 12345 local spring = Spring ( state , speed ) Since a speed of 0 is equivalent to a spring that doesn't move, any slower speed is not simulatable or physically sensible. since v0.1 mistypedSpringDamping \u00b6 The damping ratio for a spring must be a number. (got a boolean) This message shows if you try to provide a damping ratio to a spring which isn't a number: local speed = 10 local damping = true local spring = Spring ( state , speed , damping ) since v0.1 mistypedSpringSpeed \u00b6 The speed of a spring must be a number. (got a boolean) This message shows if you try to provide a speed to a spring which isn't a number: local speed = true local spring = Spring ( state , speed ) since v0.2 onDestroyNilRef \u00b6 `onDestroy` got a nil ref! (this is an internal issue, was the instance lost too early?) In order to track when an instance is destroyed by Roblox, Fusion uses an internal function called onDestroy . If this function receives nil instead of an instance, this error will be thrown. This may indicate that cleanup code is not getting registered properly internally, which can lead to large memory leaks. For that reason, this should be reported as soon as possible. since v0.1 mistypedTweenInfo \u00b6 The tween info of a tween must be a TweenInfo. (got a boolean) This message shows if you try to provide a tween info to a tween which isn't a TweenInfo: local tweenInfo = true local tween = Tween ( state , tweenInfo ) since v0.2 springTypeMismatch \u00b6 The type 'number' doesn't match the spring's type 'Color3'. Some methods on spring objects require incoming values to match the types previously being used on the spring. This message shows when an incoming value doesn't have the same type as values used previously on the spring: local colour = State ( Color3 . new ( 1 , 0 , 0 )) local colourSpring = Spring ( colour ) colourSpring : addVelocity ( Vector2 . new ( 2 , 3 )) since v0.1 strictReadError \u00b6 'Foo' is not a valid member of 'Bar'. In Fusion, some tables may have strict reading rules. This is typically used on public APIs as a defense against typos. This message shows when trying to read a non-existent member of these tables. since v0.1 unknownMessage \u00b6 Unknown error: attempt to index a nil value If you see this message, it's almost certainly an internal bug, so make sure to get in contact so the issue can be fixed. When Fusion code attempts to log a message, warning or error, it needs to provide an ID. This ID is used to show the correct message, and serves as a simple, memorable identifier if you need to look up the message later. However, if that code provides an invalid ID, then the message will be replaced with this one. since v0.1 unrecognisedChildType \u00b6 'number' type children aren't accepted as children in `New`. This message shows when attempting to pass something as a child which isn't an instance, table of instances, or state object containing an instance (when using the New function): local instance = New \"Folder\" { [ Children ] = { 1 , 2 , 3 , 4 , 5 , { true , false }, State ( Enum . Material . Grass ) } } Note Note that state objects are allowed to store nil to represent the absence of an instance, as an exception to these rules. since v0.1 unrecognisedPropertyKey \u00b6 'number' keys aren't accepted in the property table of `New`. When you create an instance in Fusion using New , you can pass in a 'property table' containing properties, children, event and property change handlers, etc. This table is only expected to contain keys of two types: string keys, e.g. Name = \"Example\" a few symbol keys, e.g. [ OnEvent \"Foo\" ] = ... This message shows if Fusion finds a key of a different type, or if the key isn't one of the few symbol keys used in New: local folder = New \"Folder\" { [ Vector3 . new ()] = \"Example\" , \"This\" , \"Shouldn't\" , \"Be\" , \"Here\" } since v0.2 unrecognisedPropertyStage \u00b6 'discombobulate' isn't a valid stage for a special key to be applied at. Fusion provides a standard interface for defining special keys which can be used to extend the functionality of New or Hydrate . Within this interface, keys can select when they run using the stage field. If an unexpected value is passed as the stage, then this error will be thrown when attempting to use the key. local Example = { type = \"SpecialKey\" , kind = \"Example\" , stage = \"discombobulate\" , apply = function () ... end } local folder = New \"Folder\" { [ Example ] = \"foo\" }","title":"Index"},{"location":"api-reference/errors/#errors","text":"Whenever Fusion outputs any errors or messages to the console, it will have a short error ID at the end. This is used to uniquely identify what kind of error or message you're seeing. Use the search box below to paste in or type an error ID, and it will scroll to the details for you. since v0.2","title":"\n    Errors"},{"location":"api-reference/errors/#applypropsnilref","text":"`applyInstanceProps` got a nil ref! (this is an internal issue) Internally in Fusion, the New and Hydrate functions call a helper function, applyInstanceProps , to do the work of binding properties and applying special keys. If that function is given nil instead of an instance, this error is thrown. This could occur if internal code accidentally destroys an instance via garbage collection, which could have large implications for projects using Fusion. The error and reproduction steps should be reported as soon as possible. since v0.1","title":"applyPropsNilRef"},{"location":"api-reference/errors/#cannotassignproperty","text":"The class type 'Foo' has no assignable property 'Bar'. This message shows if you try to assign a non-existent or locked property using the New or Hydrate functions: local folder = New \"Folder\" { DataCost = 12345 , ThisPropertyDoesntExist = \"Example\" } Tip Different scripts may have different privileges - for example, plugins will be allowed more privileges than in-game scripts. Make sure you have the necessary privileges to assign to your properties! since v0.1","title":"cannotAssignProperty"},{"location":"api-reference/errors/#cannotconnectchange","text":"The Frame class doesn't have a property called 'Foo'. This message shows if you try to connect a handler to a non-existent property change event when using the New or Hydrate functions: local textBox = New \"TextBox\" { [ OnChange \"ThisPropertyDoesntExist\" ] = function () ... end ) } since v0.1","title":"cannotConnectChange"},{"location":"api-reference/errors/#cannotconnectevent","text":"The Frame class doesn't have an event called 'Foo'. This message shows if you try to connect a handler to a non-existent event when using the New or Hydrate functions: local button = New \"TextButton\" { [ OnEvent \"ThisEventDoesntExist\" ] = function () ... end ) } since v0.1","title":"cannotConnectEvent"},{"location":"api-reference/errors/#cannotcreateclass","text":"Can't create a new instance of class 'Foo'. This message shows when using the New function with an invalid class type: local instance = New \"ThisClassTypeIsInvalid\" { ... } since v0.1","title":"cannotCreateClass"},{"location":"api-reference/errors/#computedcallbackerror","text":"Computed callback error: attempt to index a nil value This message shows when the callback of a computed object encounters an error: local example = Computed ( function () local badMath = 2 + \"fish\" end ) since v0.2","title":"computedCallbackError"},{"location":"api-reference/errors/#duplicatepropertykey","text":"Can't assign to 'Name' twice. This message shows if you try to declare the same property more than once when using the New or Hydrate functions: local button = New \"TextButton\" { Name = \"Joseph\" } Hydrate ( button ) { Name = \"Simon\" -- ambiguous! Is the name supposed to be Joseph or Simon? } since v0.2","title":"duplicatePropertyKey"},{"location":"api-reference/errors/#invalidchangehandler","text":"The change handler for the 'Text' property must be a function. This message shows if you try to give OnChange something other than a function: local input = New \"TextBox\" { [ OnChange \"Text\" ] = \"lemons\" } since v0.2","title":"invalidChangeHandler"},{"location":"api-reference/errors/#invalideventhandler","text":"The handler for the 'Activated' event must be a function. This message shows if you try to give OnEvent something other than a function: local button = New \"TextButton\" { [ OnEvent \"Activated\" ] = \"limes\" } since v0.2","title":"invalidEventHandler"},{"location":"api-reference/errors/#invalidpropertytype","text":"'Frame.Size' expected a 'UDim2' type, but got a 'Color3' type. When using the New or Hydrate functions, you can pass values to properties. If you pass a value of the wrong type for that property, and Roblox can't convert it, this error will be shown. local ui = New \"Frame\" { Size = Computed ( function () return Color3 . new ( 1 , 0 , 0 ) end ) } since v0.2","title":"invalidPropertyType"},{"location":"api-reference/errors/#invalidreftype","text":"Instance refs must be Value objects. The Ref key expects a Value object so it can store the instance reference inside of it. This error is thrown if it receives something that is not a Value object. local thing = New \"Part\" { [ Ref ] = 2 } since v0.2","title":"invalidRefType"},{"location":"api-reference/errors/#invalidouttype","text":"[Out] properties must be given Value objects. Keys made using Out expect a Value object so they can store property values inside of it. This error is thrown if it receives something that is not a Value object. local thing = New \"Part\" { [ Out \"Color\" ] = true } since v0.2","title":"invalidOutType"},{"location":"api-reference/errors/#invalidoutproperty","text":"The Part class doesn't have a property called 'Flobulator'. This error is thrown if a property name is used with Out which doesn't exist or can't be accessed. local value = Value () local thing = New \"Part\" { [ Out \"Flobulator\" ] = value } since v0.1","title":"invalidOutProperty"},{"location":"api-reference/errors/#invalidspringdamping","text":"The damping ratio for a spring must be >= 0. (damping was -0.50) This message shows if you try to provide a damping ratio to a spring which is less than 0: local speed = 10 local damping = - 12345 local spring = Spring ( state , speed , damping ) Damping ratio must always be between 0 and infinity for a spring to be physically simulatable. since v0.1","title":"invalidSpringDamping"},{"location":"api-reference/errors/#invalidspringspeed","text":"The speed of a spring must be >= 0. (speed was -2.00) This message shows if you try to provide a speed to a spring which is less than 0: local speed = - 12345 local spring = Spring ( state , speed ) Since a speed of 0 is equivalent to a spring that doesn't move, any slower speed is not simulatable or physically sensible. since v0.1","title":"invalidSpringSpeed"},{"location":"api-reference/errors/#mistypedspringdamping","text":"The damping ratio for a spring must be a number. (got a boolean) This message shows if you try to provide a damping ratio to a spring which isn't a number: local speed = 10 local damping = true local spring = Spring ( state , speed , damping ) since v0.1","title":"mistypedSpringDamping"},{"location":"api-reference/errors/#mistypedspringspeed","text":"The speed of a spring must be a number. (got a boolean) This message shows if you try to provide a speed to a spring which isn't a number: local speed = true local spring = Spring ( state , speed ) since v0.2","title":"mistypedSpringSpeed"},{"location":"api-reference/errors/#ondestroynilref","text":"`onDestroy` got a nil ref! (this is an internal issue, was the instance lost too early?) In order to track when an instance is destroyed by Roblox, Fusion uses an internal function called onDestroy . If this function receives nil instead of an instance, this error will be thrown. This may indicate that cleanup code is not getting registered properly internally, which can lead to large memory leaks. For that reason, this should be reported as soon as possible. since v0.1","title":"onDestroyNilRef"},{"location":"api-reference/errors/#mistypedtweeninfo","text":"The tween info of a tween must be a TweenInfo. (got a boolean) This message shows if you try to provide a tween info to a tween which isn't a TweenInfo: local tweenInfo = true local tween = Tween ( state , tweenInfo ) since v0.2","title":"mistypedTweenInfo"},{"location":"api-reference/errors/#springtypemismatch","text":"The type 'number' doesn't match the spring's type 'Color3'. Some methods on spring objects require incoming values to match the types previously being used on the spring. This message shows when an incoming value doesn't have the same type as values used previously on the spring: local colour = State ( Color3 . new ( 1 , 0 , 0 )) local colourSpring = Spring ( colour ) colourSpring : addVelocity ( Vector2 . new ( 2 , 3 )) since v0.1","title":"springTypeMismatch"},{"location":"api-reference/errors/#strictreaderror","text":"'Foo' is not a valid member of 'Bar'. In Fusion, some tables may have strict reading rules. This is typically used on public APIs as a defense against typos. This message shows when trying to read a non-existent member of these tables. since v0.1","title":"strictReadError"},{"location":"api-reference/errors/#unknownmessage","text":"Unknown error: attempt to index a nil value If you see this message, it's almost certainly an internal bug, so make sure to get in contact so the issue can be fixed. When Fusion code attempts to log a message, warning or error, it needs to provide an ID. This ID is used to show the correct message, and serves as a simple, memorable identifier if you need to look up the message later. However, if that code provides an invalid ID, then the message will be replaced with this one. since v0.1","title":"unknownMessage"},{"location":"api-reference/errors/#unrecognisedchildtype","text":"'number' type children aren't accepted as children in `New`. This message shows when attempting to pass something as a child which isn't an instance, table of instances, or state object containing an instance (when using the New function): local instance = New \"Folder\" { [ Children ] = { 1 , 2 , 3 , 4 , 5 , { true , false }, State ( Enum . Material . Grass ) } } Note Note that state objects are allowed to store nil to represent the absence of an instance, as an exception to these rules. since v0.1","title":"unrecognisedChildType"},{"location":"api-reference/errors/#unrecognisedpropertykey","text":"'number' keys aren't accepted in the property table of `New`. When you create an instance in Fusion using New , you can pass in a 'property table' containing properties, children, event and property change handlers, etc. This table is only expected to contain keys of two types: string keys, e.g. Name = \"Example\" a few symbol keys, e.g. [ OnEvent \"Foo\" ] = ... This message shows if Fusion finds a key of a different type, or if the key isn't one of the few symbol keys used in New: local folder = New \"Folder\" { [ Vector3 . new ()] = \"Example\" , \"This\" , \"Shouldn't\" , \"Be\" , \"Here\" } since v0.2","title":"unrecognisedPropertyKey"},{"location":"api-reference/errors/#unrecognisedpropertystage","text":"'discombobulate' isn't a valid stage for a special key to be applied at. Fusion provides a standard interface for defining special keys which can be used to extend the functionality of New or Hydrate . Within this interface, keys can select when they run using the stage field. If an unexpected value is passed as the stage, then this error will be thrown when attempting to use the key. local Example = { type = \"SpecialKey\" , kind = \"Example\" , stage = \"discombobulate\" , apply = function () ... end } local folder = New \"Folder\" { [ Example ] = \"foo\" }","title":"unrecognisedPropertyStage"},{"location":"api-reference/instances/","text":"Fusion Instances \u00b6 Utilities for connecting state objects to instances via code. Types \u00b6 Child Component SemiWeakRef SpecialKey Functions \u00b6 Hydrate New OnChange OnEvent Out Special Keys \u00b6 Children Cleanup Ref","title":"Index"},{"location":"api-reference/instances/#instances","text":"Utilities for connecting state objects to instances via code.","title":"\n    Instances"},{"location":"api-reference/instances/#types","text":"Child Component SemiWeakRef SpecialKey","title":"Types"},{"location":"api-reference/instances/#functions","text":"Hydrate New OnChange OnEvent Out","title":"Functions"},{"location":"api-reference/instances/#special-keys","text":"Children Cleanup Ref","title":"Special Keys"},{"location":"api-reference/instances/child/","text":"Fusion Instances Child type since v0.2 \u00b6 Represents some UI which can be parented to an ancestor, usually via Children . The most simple kind of child is a single instance, though arrays can be used to parent multiple instances at once and state objects can be used to make the children dynamic. Instance | { Child } | StateObject < Child > Example Usage \u00b6 -- all of the following fit the definition of Child local child1 : Child = New \"Folder\" {} local child2 : Child = { New \"Folder\" {}, New \"Folder\" {}, New \"Folder\" {} } local child3 : Child = Computed ( function () return New \"Folder\" {} end ) local child4 : Child = { Computed ( function () return New \"Folder\" {} end ), { New \"Folder\" {}, New \"Folder\" {}} }","title":"Child"},{"location":"api-reference/instances/child/#child-type-since-v02","text":"Represents some UI which can be parented to an ancestor, usually via Children . The most simple kind of child is a single instance, though arrays can be used to parent multiple instances at once and state objects can be used to make the children dynamic. Instance | { Child } | StateObject < Child >","title":"\n    Child\n    \n        type\n        since v0.2\n    "},{"location":"api-reference/instances/child/#example-usage","text":"-- all of the following fit the definition of Child local child1 : Child = New \"Folder\" {} local child2 : Child = { New \"Folder\" {}, New \"Folder\" {}, New \"Folder\" {} } local child3 : Child = Computed ( function () return New \"Folder\" {} end ) local child4 : Child = { Computed ( function () return New \"Folder\" {} end ), { New \"Folder\" {}, New \"Folder\" {}} }","title":"Example Usage"},{"location":"api-reference/instances/children/","text":"Fusion Instances Children special key since v0.1 \u00b6 Allows parenting children to an instance, both statically and dynamically. Example Usage \u00b6 local example = New \"Folder\" { [ Children ] = New \"StringValue\" { Value = \"I'm parented to the Folder!\" } } Processing Children \u00b6 A 'child' is defined (recursively) as: an instance a state object containing children an array of children Since this definition is recursive, arrays and state objects can be nested; that is, the following code is valid: local example = New \"Folder\" { [ Children ] = { { { New \"StringValue\" { Value = \"I'm parented to the Folder!\" } } } } } This behaviour is especially useful when working with components - the following component can return multiple instances to be parented without disrupting the code next to it: local function Component ( props ) return { New \"TextLabel\" { LayoutOrder = 1 , Text = \"Instance one\" }, New \"TextLabel\" { LayoutOrder = 2 , Text = \"Instance two\" } } end local parent = New \"Frame\" { Children = { New \"UIListLayout\" { SortOrder = \"LayoutOrder\" }, Component {} } } When using a state object as a child, Children will interpret the stored value as children and watch for changes. When the value of the state object changes, it'll unparent the old children and parent the new children. Note As with bound properties, updates are deferred to the next render step, and so parenting won't occur right away. local child1 = New \"Folder\" { Name = \"Child one\" } local child2 = New \"Folder\" { Name = \"Child two\" } local childState = State ( child1 ) local parent = New \"Folder\" { [ Children ] = childState } print ( parent : GetChildren ()) -- { Child one } childState : set ( child2 ) wait ( 1 ) -- wait for deferred updates to run print ( parent : GetChildren ()) -- { Child two } Warning When using state objects, note that old children won't be destroyed, only unparented - it's up to you to decide if/when children need to be destroyed. If you're using a helper like ForValues , instance cleanup is handled for you by default (though this is configurable). Technical Details \u00b6 This special key runs at the descendants stage. On cleanup, all children are unparented, as if wrapped in a state object that has changed to nil.","title":"Children"},{"location":"api-reference/instances/children/#children-special-key-since-v01","text":"Allows parenting children to an instance, both statically and dynamically.","title":"\n    Children\n    \n        special key\n        since v0.1\n    "},{"location":"api-reference/instances/children/#example-usage","text":"local example = New \"Folder\" { [ Children ] = New \"StringValue\" { Value = \"I'm parented to the Folder!\" } }","title":"Example Usage"},{"location":"api-reference/instances/children/#processing-children","text":"A 'child' is defined (recursively) as: an instance a state object containing children an array of children Since this definition is recursive, arrays and state objects can be nested; that is, the following code is valid: local example = New \"Folder\" { [ Children ] = { { { New \"StringValue\" { Value = \"I'm parented to the Folder!\" } } } } } This behaviour is especially useful when working with components - the following component can return multiple instances to be parented without disrupting the code next to it: local function Component ( props ) return { New \"TextLabel\" { LayoutOrder = 1 , Text = \"Instance one\" }, New \"TextLabel\" { LayoutOrder = 2 , Text = \"Instance two\" } } end local parent = New \"Frame\" { Children = { New \"UIListLayout\" { SortOrder = \"LayoutOrder\" }, Component {} } } When using a state object as a child, Children will interpret the stored value as children and watch for changes. When the value of the state object changes, it'll unparent the old children and parent the new children. Note As with bound properties, updates are deferred to the next render step, and so parenting won't occur right away. local child1 = New \"Folder\" { Name = \"Child one\" } local child2 = New \"Folder\" { Name = \"Child two\" } local childState = State ( child1 ) local parent = New \"Folder\" { [ Children ] = childState } print ( parent : GetChildren ()) -- { Child one } childState : set ( child2 ) wait ( 1 ) -- wait for deferred updates to run print ( parent : GetChildren ()) -- { Child two } Warning When using state objects, note that old children won't be destroyed, only unparented - it's up to you to decide if/when children need to be destroyed. If you're using a helper like ForValues , instance cleanup is handled for you by default (though this is configurable).","title":"Processing Children"},{"location":"api-reference/instances/children/#technical-details","text":"This special key runs at the descendants stage. On cleanup, all children are unparented, as if wrapped in a state object that has changed to nil.","title":"Technical Details"},{"location":"api-reference/instances/component/","text":"Fusion Instances Component type since v0.2 \u00b6 The standard type signature for UI components. They accept a property table and return a child type . ( props : {[ any ]: any }) -> Child Example Usage \u00b6 -- create a Button component local function Button ( props ) return New \"TextButton\" { Text = props . Text } end -- our Button component is compatible with the Component type local myComponent : Component = Button","title":"Component"},{"location":"api-reference/instances/component/#component-type-since-v02","text":"The standard type signature for UI components. They accept a property table and return a child type . ( props : {[ any ]: any }) -> Child","title":"\n    Component\n    \n        type\n        since v0.2\n    "},{"location":"api-reference/instances/component/#example-usage","text":"-- create a Button component local function Button ( props ) return New \"TextButton\" { Text = props . Text } end -- our Button component is compatible with the Component type local myComponent : Component = Button","title":"Example Usage"},{"location":"api-reference/instances/hydrate/","text":"Fusion Instances Hydrate function since v0.2 \u00b6 Given an instance, returns a component which modifies that instance. The property table may specify properties to set on the instance, or include special keys for more advanced operations. ( target : Instance ) -> Component Parameters \u00b6 target - the instance which the component should modify Returns \u00b6 A component function. When called, it populates the target instance using the property table, then returns the target instance. Example Usage \u00b6 local myButton : TextButton = Hydrate ( PlayerGui . ScreenGui . TextButton ) { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Hello, world!\" , [ OnEvent \"Activated\" ] = function () print ( \"The button was clicked!\" ) end , [ OnChange \"Name\" ] = function ( newName ) print ( \"The button was renamed to:\" , newName ) end , [ Children ] = New \"UICorner\" { CornerRadius = UDim . new ( 0 , 8 ) } } Property Table Processing \u00b6 The props table uses a mix of string and special keys to specify attributes of the instance which should be set. String keys are treated as property declarations - values passed in will be set upon the instance: local example = Hydrate ( workspace . Part ) { -- sets the Position property Position = Vector3 . new ( 1 , 2 , 3 ) } Passing a state object to a string key will bind the property value; when the value of the object changes, the property will update to match on the next resumption step: local myName = State ( \"Bob\" ) local example = Hydrate ( workspace . Part ) { -- initially, the Name will be set to Bob Name = myName } -- change the state object to store \"John\" -- on the next resumption step, the part's Name will change to John myName : set ( \"John\" ) Special keys, such as Children or OnEvent , may also be used as keys in the property table. For more information about how special keys work, see the SpecialKey page.","title":"Hydrate"},{"location":"api-reference/instances/hydrate/#hydrate-function-since-v02","text":"Given an instance, returns a component which modifies that instance. The property table may specify properties to set on the instance, or include special keys for more advanced operations. ( target : Instance ) -> Component","title":"\n    Hydrate\n    \n        function\n        since v0.2\n    "},{"location":"api-reference/instances/hydrate/#parameters","text":"target - the instance which the component should modify","title":"Parameters"},{"location":"api-reference/instances/hydrate/#returns","text":"A component function. When called, it populates the target instance using the property table, then returns the target instance.","title":"Returns"},{"location":"api-reference/instances/hydrate/#example-usage","text":"local myButton : TextButton = Hydrate ( PlayerGui . ScreenGui . TextButton ) { Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Hello, world!\" , [ OnEvent \"Activated\" ] = function () print ( \"The button was clicked!\" ) end , [ OnChange \"Name\" ] = function ( newName ) print ( \"The button was renamed to:\" , newName ) end , [ Children ] = New \"UICorner\" { CornerRadius = UDim . new ( 0 , 8 ) } }","title":"Example Usage"},{"location":"api-reference/instances/hydrate/#property-table-processing","text":"The props table uses a mix of string and special keys to specify attributes of the instance which should be set. String keys are treated as property declarations - values passed in will be set upon the instance: local example = Hydrate ( workspace . Part ) { -- sets the Position property Position = Vector3 . new ( 1 , 2 , 3 ) } Passing a state object to a string key will bind the property value; when the value of the object changes, the property will update to match on the next resumption step: local myName = State ( \"Bob\" ) local example = Hydrate ( workspace . Part ) { -- initially, the Name will be set to Bob Name = myName } -- change the state object to store \"John\" -- on the next resumption step, the part's Name will change to John myName : set ( \"John\" ) Special keys, such as Children or OnEvent , may also be used as keys in the property table. For more information about how special keys work, see the SpecialKey page.","title":"Property Table Processing"},{"location":"api-reference/instances/new/","text":"Fusion Instances New function since v0.1 \u00b6 Given a class name, returns a component which creates instances of that class. The property table may specify properties to set on the instance, or include special keys for more advanced operations. ( className : string ) -> Component Parameters \u00b6 className - the instance class that should be created Returns \u00b6 A component function. When called, it creates a new instance of the given class, populates it using the property table, and returns it. Example Usage \u00b6 local myButton : TextButton = New \"TextButton\" { Parent = Players . LocalPlayer . PlayerGui , Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Hello, world!\" , [ OnEvent \"Activated\" ] = function () print ( \"The button was clicked!\" ) end , [ OnChange \"Name\" ] = function ( newName ) print ( \"The button was renamed to:\" , newName ) end , [ Children ] = New \"UICorner\" { CornerRadius = UDim . new ( 0 , 8 ) } } Property Table Processing \u00b6 The props table uses a mix of string and special keys to specify attributes of the instance which should be set. String keys are treated as property declarations - values passed in will be set upon the instance: local example = New \"Part\" { -- sets the Position property Position = Vector3 . new ( 1 , 2 , 3 ) } Passing a state object to a string key will bind the property value; when the value of the object changes, the property will update to match on the next resumption step: local myName = State ( \"Bob\" ) local example = New \"Part\" { -- initially, the Name will be set to Bob Name = myName } -- change the state object to store \"John\" -- on the next resumption step, the part's Name will change to John myName : set ( \"John\" ) Special keys, such as Children or OnEvent , may also be used as keys in the property table. For more information about how special keys work, see the SpecialKey page. Default Properties \u00b6 The New function provides its own set of 'sensible default' property values for some class types, which will be used in place of Roblox defaults. This is done to opt out of some legacy features and unhelpful defaults. You can see the default properties Fusion uses here.","title":"New"},{"location":"api-reference/instances/new/#new-function-since-v01","text":"Given a class name, returns a component which creates instances of that class. The property table may specify properties to set on the instance, or include special keys for more advanced operations. ( className : string ) -> Component","title":"\n    New\n    \n        function\n        since v0.1\n    "},{"location":"api-reference/instances/new/#parameters","text":"className - the instance class that should be created","title":"Parameters"},{"location":"api-reference/instances/new/#returns","text":"A component function. When called, it creates a new instance of the given class, populates it using the property table, and returns it.","title":"Returns"},{"location":"api-reference/instances/new/#example-usage","text":"local myButton : TextButton = New \"TextButton\" { Parent = Players . LocalPlayer . PlayerGui , Position = UDim2 . fromScale ( .5 , .5 ), AnchorPoint = Vector2 . new ( .5 , .5 ), Size = UDim2 . fromOffset ( 200 , 50 ), Text = \"Hello, world!\" , [ OnEvent \"Activated\" ] = function () print ( \"The button was clicked!\" ) end , [ OnChange \"Name\" ] = function ( newName ) print ( \"The button was renamed to:\" , newName ) end , [ Children ] = New \"UICorner\" { CornerRadius = UDim . new ( 0 , 8 ) } }","title":"Example Usage"},{"location":"api-reference/instances/new/#property-table-processing","text":"The props table uses a mix of string and special keys to specify attributes of the instance which should be set. String keys are treated as property declarations - values passed in will be set upon the instance: local example = New \"Part\" { -- sets the Position property Position = Vector3 . new ( 1 , 2 , 3 ) } Passing a state object to a string key will bind the property value; when the value of the object changes, the property will update to match on the next resumption step: local myName = State ( \"Bob\" ) local example = New \"Part\" { -- initially, the Name will be set to Bob Name = myName } -- change the state object to store \"John\" -- on the next resumption step, the part's Name will change to John myName : set ( \"John\" ) Special keys, such as Children or OnEvent , may also be used as keys in the property table. For more information about how special keys work, see the SpecialKey page.","title":"Property Table Processing"},{"location":"api-reference/instances/new/#default-properties","text":"The New function provides its own set of 'sensible default' property values for some class types, which will be used in place of Roblox defaults. This is done to opt out of some legacy features and unhelpful defaults. You can see the default properties Fusion uses here.","title":"Default Properties"},{"location":"api-reference/instances/onchange/","text":"Fusion Instances OnChange function since v0.1 \u00b6 Given a property name, returns a special key which connects to that property's change events. It should be used with a handler callback, which may accept the new value of the property. ( propertyName : string ) -> SpecialKey Parameters \u00b6 propertyName - The name of the property to listen for changes to. Returns \u00b6 A special key which runs at the observer stage. When applied to an instance, it connects to the property change signal on the instance for the given property. The handler is run with the property's value after every change. Example Usage \u00b6 New \"TextBox\" { [ OnChange \"Text\" ] = function ( newText ) print ( \"You typed:\" , newText ) end }","title":"OnChange"},{"location":"api-reference/instances/onchange/#onchange-function-since-v01","text":"Given a property name, returns a special key which connects to that property's change events. It should be used with a handler callback, which may accept the new value of the property. ( propertyName : string ) -> SpecialKey","title":"\n    OnChange\n    \n        function\n        since v0.1\n    "},{"location":"api-reference/instances/onchange/#parameters","text":"propertyName - The name of the property to listen for changes to.","title":"Parameters"},{"location":"api-reference/instances/onchange/#returns","text":"A special key which runs at the observer stage. When applied to an instance, it connects to the property change signal on the instance for the given property. The handler is run with the property's value after every change.","title":"Returns"},{"location":"api-reference/instances/onchange/#example-usage","text":"New \"TextBox\" { [ OnChange \"Text\" ] = function ( newText ) print ( \"You typed:\" , newText ) end }","title":"Example Usage"},{"location":"api-reference/instances/onevent/","text":"Fusion Instances OnEvent function since v0.1 \u00b6 Given an event name, returns a special key which connects to events of that name. It should be used with a handler callback, which may accept arguments from the event. ( eventName : string ) -> SpecialKey Parameters \u00b6 eventName - the name of the event to connect to Returns \u00b6 A special key which runs at the observer stage. When applied to an instance, it connects to the event on the instance of the given name. The handler is run with the event's arguments after every firing. Example Usage \u00b6 New \"TextButton\" { [ OnEvent \"Activated\" ] = function (...) print ( \"The button was clicked! Arguments:\" , ...) end }","title":"OnEvent"},{"location":"api-reference/instances/onevent/#onevent-function-since-v01","text":"Given an event name, returns a special key which connects to events of that name. It should be used with a handler callback, which may accept arguments from the event. ( eventName : string ) -> SpecialKey","title":"\n    OnEvent\n    \n        function\n        since v0.1\n    "},{"location":"api-reference/instances/onevent/#parameters","text":"eventName - the name of the event to connect to","title":"Parameters"},{"location":"api-reference/instances/onevent/#returns","text":"A special key which runs at the observer stage. When applied to an instance, it connects to the event on the instance of the given name. The handler is run with the event's arguments after every firing.","title":"Returns"},{"location":"api-reference/instances/onevent/#example-usage","text":"New \"TextButton\" { [ OnEvent \"Activated\" ] = function (...) print ( \"The button was clicked! Arguments:\" , ...) end }","title":"Example Usage"},{"location":"api-reference/instances/out/","text":"Fusion Instances Out function since v0.2 \u00b6 Given a property name, returns a special key which outputs the value of properties with that name. It should be used with a value . ( propertyName : string ) -> SpecialKey Parameters \u00b6 propertyName - The name of the property to output the value of. Returns \u00b6 A special key which runs at the observer stage. When applied to an instance, it sets the value object equal to the property with the given name. It then listens for further changes and updates the value object accordingly. Example Usage \u00b6 local userText = Value () New \"TextBox\" { [ Out \"Text\" ] = userText } Observer ( userText ): onChange ( function () print ( \"The user typed:\" , userText : get ()) end )","title":"Out"},{"location":"api-reference/instances/out/#out-function-since-v02","text":"Given a property name, returns a special key which outputs the value of properties with that name. It should be used with a value . ( propertyName : string ) -> SpecialKey","title":"\n    Out\n    \n        function\n        since v0.2\n    "},{"location":"api-reference/instances/out/#parameters","text":"propertyName - The name of the property to output the value of.","title":"Parameters"},{"location":"api-reference/instances/out/#returns","text":"A special key which runs at the observer stage. When applied to an instance, it sets the value object equal to the property with the given name. It then listens for further changes and updates the value object accordingly.","title":"Returns"},{"location":"api-reference/instances/out/#example-usage","text":"local userText = Value () New \"TextBox\" { [ Out \"Text\" ] = userText } Observer ( userText ): onChange ( function () print ( \"The user typed:\" , userText : get ()) end )","title":"Example Usage"},{"location":"api-reference/instances/ref/","text":"Fusion Instances Ref special key since v0.2 \u00b6 When applied to an instance, outputs the instance to a state object. It should be used with a value . Example Usage \u00b6 local myRef = Value () New \"Part\" { [ Ref ] = myRef } print ( myRef : get ()) --> Part Technical Details \u00b6 This special key runs at the observer stage. On cleanup, the state object is reset to nil, in order to avoid potential memory leaks.","title":"Ref"},{"location":"api-reference/instances/ref/#ref-special-key-since-v02","text":"When applied to an instance, outputs the instance to a state object. It should be used with a value .","title":"\n    Ref\n    \n        special key\n        since v0.2\n    "},{"location":"api-reference/instances/ref/#example-usage","text":"local myRef = Value () New \"Part\" { [ Ref ] = myRef } print ( myRef : get ()) --> Part","title":"Example Usage"},{"location":"api-reference/instances/ref/#technical-details","text":"This special key runs at the observer stage. On cleanup, the state object is reset to nil, in order to avoid potential memory leaks.","title":"Technical Details"},{"location":"api-reference/instances/semiweakref/","text":"Fusion Instances SemiWeakRef type since v0.2 \u00b6 A reference to an instance, which is strong only while the instance can be accessed via the data model, and is weak at all other times. This is useful to make weak references to instances stable. { type : \"SemiWeakRef\" , instance : Instance ? } Fields \u00b6 type - identifies this table as a semi-weak reference instance - the reference to the instance; this may disappear at any time Example Usage \u00b6 local ref = semiWeakRef ( workspace . Part ) workspace . Part . Parent = nil while ref . instance ~= nil do task . wait ( 1 ) end print ( \"Part has been garbage collected\" ) Garbage Collection \u00b6 The reason why semi-weak references are needed is because the default garbage collection behaviour of instances is not useful. Instance references in Lua do not share the same lifetime as the instances they represent, meaning the instance reference can be cleaned up separately from the instance being destroyed. By ensuring a strong reference is held to the instance while it is in the data model, SemiWeakRef makes sure the instance reference is not cleaned up until the instance is in a place where the only way to reference it is by going through an existing Lua reference, and not via the data model. At this point, it is sensible to keep a weak reference, so if there are no other strong references, the instance and it's reference may be garbage collected.","title":"SemiWeakRef"},{"location":"api-reference/instances/semiweakref/#semiweakref-type-since-v02","text":"A reference to an instance, which is strong only while the instance can be accessed via the data model, and is weak at all other times. This is useful to make weak references to instances stable. { type : \"SemiWeakRef\" , instance : Instance ? }","title":"\n    SemiWeakRef\n    \n        type\n        since v0.2\n    "},{"location":"api-reference/instances/semiweakref/#fields","text":"type - identifies this table as a semi-weak reference instance - the reference to the instance; this may disappear at any time","title":"Fields"},{"location":"api-reference/instances/semiweakref/#example-usage","text":"local ref = semiWeakRef ( workspace . Part ) workspace . Part . Parent = nil while ref . instance ~= nil do task . wait ( 1 ) end print ( \"Part has been garbage collected\" )","title":"Example Usage"},{"location":"api-reference/instances/semiweakref/#garbage-collection","text":"The reason why semi-weak references are needed is because the default garbage collection behaviour of instances is not useful. Instance references in Lua do not share the same lifetime as the instances they represent, meaning the instance reference can be cleaned up separately from the instance being destroyed. By ensuring a strong reference is held to the instance while it is in the data model, SemiWeakRef makes sure the instance reference is not cleaned up until the instance is in a place where the only way to reference it is by going through an existing Lua reference, and not via the data model. At this point, it is sensible to keep a weak reference, so if there are no other strong references, the instance and it's reference may be garbage collected.","title":"Garbage Collection"},{"location":"api-reference/instances/specialkey/","text":"Fusion Instances SpecialKey type since v0.2 \u00b6 The standard interface for special keys that can be used in property tables for instance processing. Compatible with the New and Hydrate functions. { type : \"SpecialKey\" , kind : string , stage : \"self\" | \"descendants\" | \"ancestor\" | \"observer\" , apply : ( self : SpecialKey , value : any , applyTo : SemiWeakRef , cleanupTasks : { Task } ) -> () } Fields \u00b6 type - identifies this table as a special key kind - gives a developer-friendly name to the object for debugging stage - determines when the special key should apply itself during the hydration process apply - the method that will be called to apply the special key to an instance Example Usage \u00b6 local Example = {} Example . type = \"SpecialKey\" Example . kind = \"Example\" Example . stage = \"observer\" function Example : apply ( value , applyTo , cleanupTasks ) local conn = applyTo . instance : GetAttributeChangedSignal ( \"Foo\" ): Connect ( function () print ( \"My value is\" , value ) end ) table.insert ( cleanupTasks , conn ) end Stages \u00b6 When using New and Hydrate , properties are applied in the following order: String keys, except Parent Special keys with stage = \"self\" Special keys with stage = \"descendants\" Parent, if provided Special keys with stage = \"ancestor\" Special keys with stage = \"observer\" There are multiple motivations for splitting special keys into stages like these: Before we parent descendants to the instance, we want to initialise all of the instance's properties that don't depend on anything else Before we parent the instance to an ancestor, we want to parent and initialise all of the instance's descendants as fully as possible Before we attach handlers to anything, we want to parent to and initialise the instance's ancestor as fully as possible For these reasons, the roles of each stage are as follows: self \u00b6 The self stage is used for special keys that run before descendants are parented. This is typically used for special keys that operate on the instance itself in a vacuum. descendants \u00b6 The descendants stage is used for special keys that need to deal with descendants, but which don't need to know about the ancestry. This is important because parenting descendants after the instance is parented to an ancestor can be more expensive in terms of performance. ancestor \u00b6 The ancestor stage is used for special keys that deal with the ancestor of the instance. This is the last stage that should be used for initialising the instance, and occurs after the Parent has been set. observer \u00b6 The observer stage is used for special keys that watch the instance for changes or export references to the instance. This stage is where any event handlers should be connected, as initialisation should be done by this point.","title":"SpecialKey"},{"location":"api-reference/instances/specialkey/#specialkey-type-since-v02","text":"The standard interface for special keys that can be used in property tables for instance processing. Compatible with the New and Hydrate functions. { type : \"SpecialKey\" , kind : string , stage : \"self\" | \"descendants\" | \"ancestor\" | \"observer\" , apply : ( self : SpecialKey , value : any , applyTo : SemiWeakRef , cleanupTasks : { Task } ) -> () }","title":"\n    SpecialKey\n    \n        type\n        since v0.2\n    "},{"location":"api-reference/instances/specialkey/#fields","text":"type - identifies this table as a special key kind - gives a developer-friendly name to the object for debugging stage - determines when the special key should apply itself during the hydration process apply - the method that will be called to apply the special key to an instance","title":"Fields"},{"location":"api-reference/instances/specialkey/#example-usage","text":"local Example = {} Example . type = \"SpecialKey\" Example . kind = \"Example\" Example . stage = \"observer\" function Example : apply ( value , applyTo , cleanupTasks ) local conn = applyTo . instance : GetAttributeChangedSignal ( \"Foo\" ): Connect ( function () print ( \"My value is\" , value ) end ) table.insert ( cleanupTasks , conn ) end","title":"Example Usage"},{"location":"api-reference/instances/specialkey/#stages","text":"When using New and Hydrate , properties are applied in the following order: String keys, except Parent Special keys with stage = \"self\" Special keys with stage = \"descendants\" Parent, if provided Special keys with stage = \"ancestor\" Special keys with stage = \"observer\" There are multiple motivations for splitting special keys into stages like these: Before we parent descendants to the instance, we want to initialise all of the instance's properties that don't depend on anything else Before we parent the instance to an ancestor, we want to parent and initialise all of the instance's descendants as fully as possible Before we attach handlers to anything, we want to parent to and initialise the instance's ancestor as fully as possible For these reasons, the roles of each stage are as follows:","title":"Stages"},{"location":"api-reference/instances/specialkey/#self","text":"The self stage is used for special keys that run before descendants are parented. This is typically used for special keys that operate on the instance itself in a vacuum.","title":"self"},{"location":"api-reference/instances/specialkey/#descendants","text":"The descendants stage is used for special keys that need to deal with descendants, but which don't need to know about the ancestry. This is important because parenting descendants after the instance is parented to an ancestor can be more expensive in terms of performance.","title":"descendants"},{"location":"api-reference/instances/specialkey/#ancestor","text":"The ancestor stage is used for special keys that deal with the ancestor of the instance. This is the last stage that should be used for initialising the instance, and occurs after the Parent has been set.","title":"ancestor"},{"location":"api-reference/instances/specialkey/#observer","text":"The observer stage is used for special keys that watch the instance for changes or export references to the instance. This stage is where any event handlers should be connected, as initialisation should be done by this point.","title":"observer"},{"location":"api-reference/state/","text":"Fusion State \u00b6 Fundamental state objects and utilities for working with reactive graphs. Types \u00b6 CanBeState Dependency Dependent StateObject State Objects \u00b6 Computed ForKeys ForPairs ForValues Observer Value","title":"Index"},{"location":"api-reference/state/#state","text":"Fundamental state objects and utilities for working with reactive graphs.","title":"\n    State"},{"location":"api-reference/state/#types","text":"CanBeState Dependency Dependent StateObject","title":"Types"},{"location":"api-reference/state/#state-objects","text":"Computed ForKeys ForPairs ForValues Observer Value","title":"State Objects"},{"location":"api-reference/state/canbestate/","text":"Fusion State CanBeState type since v0.2 \u00b6 A value which may either be a state object or a constant. Provided as a convenient shorthand for indicating that constant-ness is not important. StateObject < T > | T Example Usage \u00b6 local function printItem ( item : CanBeState < string > ) if typeof ( item ) == \"string\" then -- constant print ( \"Got constant: \" , item ) else -- state object print ( \"Got state object: \" , item : get ()) end end local constant = \"Hello\" local state = Value ( \"World\" ) printItem ( constant ) --> Got constant: Hello printItem ( state ) --> Got state object: World","title":"CanBeState"},{"location":"api-reference/state/canbestate/#canbestate-type-since-v02","text":"A value which may either be a state object or a constant. Provided as a convenient shorthand for indicating that constant-ness is not important. StateObject < T > | T","title":"\n    CanBeState\n    \n        type\n        since v0.2\n    "},{"location":"api-reference/state/canbestate/#example-usage","text":"local function printItem ( item : CanBeState < string > ) if typeof ( item ) == \"string\" then -- constant print ( \"Got constant: \" , item ) else -- state object print ( \"Got state object: \" , item : get ()) end end local constant = \"Hello\" local state = Value ( \"World\" ) printItem ( constant ) --> Got constant: Hello printItem ( state ) --> Got state object: World","title":"Example Usage"},{"location":"api-reference/state/compat/","text":"function Compat ( watchedState : State < any > ): Compat Constructs and returns a new compatibility object, which will listen for events on the given watchedState object. Compat is intended as an API for integrating Fusion with other, non-Fusion code. Some example uses include synchronising theme colours to non-Fusion UIs, or saving state objects to data stores as they change. Warning You should only use Compat when dealing with non-Fusion code. If you're building an interface with Fusion, there are already reactive tools for almost every single use case, which can be better optimised by Fusion and lead to cleaner and more idiomatic code. Using Compat in these situations is highly discouraged. Changing state objects in :onChange() is a particular anti-pattern which abusing Compat may encourage. If you need to update the value of a state object when another state object is changed, consider using computed state instead. For further details, see this issue on GitHub. Parameters \u00b6 watchedState: State<any> - a state object , computed object or other state object to track. Object Methods \u00b6 onChange() \u00b6 function Compat : onChange ( callback : () -> ()): () -> () Connects the given callback as a change handler, and returns a function which will disconnect the callback. When the value of this Compat's watchedState changes, the callback will be fired. Connection memory leaks Make sure to disconnect any change handlers made using this function once you're done using them. As long as a change handler is connected, this Compat object (and the watchedState ) will be held in memory so changes can be detected. This means that, if you don't call the disconnect function, you may end up accidentally holding the state object in memory after you're done using them. Example Usage \u00b6 local numCoins = State ( 50 ) local compat = Compat ( numCoins ) local disconnect = compat : onChange ( function () print ( \"coins is now:\" , numCoins : get ()) end ) numCoins : set ( 25 ) -- prints 'coins is now: 25' -- always clean up your connections! disconnect ()","title":"Compat"},{"location":"api-reference/state/compat/#parameters","text":"watchedState: State<any> - a state object , computed object or other state object to track.","title":"Parameters"},{"location":"api-reference/state/compat/#object-methods","text":"","title":"Object Methods"},{"location":"api-reference/state/compat/#onchange","text":"function Compat : onChange ( callback : () -> ()): () -> () Connects the given callback as a change handler, and returns a function which will disconnect the callback. When the value of this Compat's watchedState changes, the callback will be fired. Connection memory leaks Make sure to disconnect any change handlers made using this function once you're done using them. As long as a change handler is connected, this Compat object (and the watchedState ) will be held in memory so changes can be detected. This means that, if you don't call the disconnect function, you may end up accidentally holding the state object in memory after you're done using them.","title":"onChange()"},{"location":"api-reference/state/compat/#example-usage","text":"local numCoins = State ( 50 ) local compat = Compat ( numCoins ) local disconnect = compat : onChange ( function () print ( \"coins is now:\" , numCoins : get ()) end ) numCoins : set ( 25 ) -- prints 'coins is now: 25' -- always clean up your connections! disconnect ()","title":"Example Usage"},{"location":"api-reference/state/computed/","text":"function Computed ( callback : () -> any ): Computed Constructs and returns a new computed object, using the given callback to compute this object's values based on other state objects or computed objects. Parameters \u00b6 callback: () -> any - a function which computes and returns the value to use for this computed object. Object Methods \u00b6 get() \u00b6 function Computed : get (): any Returns the cached value of this computed object, as returned from the callback function. If dependencies are currently being detected (e.g. inside a computed callback), then this computed object will be used as a dependency. Example Usage \u00b6 local numCoins = State ( 50 ) local doubleCoins = Computed ( function () return numCoins : get () * 2 end ) print ( doubleCoins : get ()) --> 100 numCoins : set ( 2 ) print ( doubleCoins : get ()) --> 4 Dependency Management \u00b6 Computed objects automatically detect dependencies used inside their callback each time their callback runs. This means, when you use a function like :get() on a state object, it will register that state object as a dependency: local numCoins = State ( 50 ) local doubleCoins = Computed ( function () -- Fusion detects we called :get() on `numCoins`, and so adds `numCoins` as -- a dependency of this computed object. return numCoins : get () * 2 end ) When a dependency changes value, the computed object will re-run its callback to generate and cache the current value internally. This value is later exposed via the :get() method. Something to note is that dependencies are dynamic; you can change what values your computed object depends on, and the dependencies will be updated to reduce unnecessary updates: Lua Expected output local stateA = State ( 5 ) local stateB = State ( 5 ) local selector = State ( \"A\" ) local computed = Computed ( function () print ( \"> updating computed!\" ) local selected = selector : get () if selected == \"A\" then return stateA : get () elseif selected == \"B\" then return stateB : get () end end ) print ( \"increment state A (expect update below)\" ) stateA : set ( stateA : get () + 1 ) print ( \"increment state B (expect no update)\" ) stateA : set ( stateA : get () + 1 ) print ( \"switch to select B\" ) selector : set ( \"B\" ) print ( \"increment state A (expect no update)\" ) stateA : set ( stateA : get () + 1 ) print ( \"increment state B (expect update below)\" ) stateA : set ( stateA : get () + 1 ) > updating computed! increment state A (expect update below) > updating computed! increment state B (expect no update) switch to select B > updating computed! increment state A (expect no update) increment state B (expect update below) > updating computed! Danger Stick to using state objects and computed objects inside your computations. Fusion can detect when you use these objects and listen for changes. Fusion can't automatically detect changes when you use 'normal' variables: local theVariable = \"Hello\" local badValue = Computed ( function () -- don't do this! use state objects or computed objects in here return \"Say \" .. theVariable end ) print ( badValue : get ()) -- prints 'Say Hello' theVariable = \"World\" print ( badValue : get ()) -- still prints 'Say Hello' - that's a problem! By using a state object here, Fusion can correctly update the computed object, because it knows we used the state object: local theVariable = State ( \"Hello\" ) local goodValue = Computed ( function () -- this is much better - Fusion can detect we used this state object! return \"Say \" .. theVariable : get () end ) print ( goodValue : get ()) -- prints 'Say Hello' theVariable : set ( \"World\" ) print ( goodValue : get ()) -- prints 'Say World' This also applies to any functions that change on their own, like os.clock() . If you need to use them, store values from the function in a state object, and update the value of that object as often as required.","title":"Computed"},{"location":"api-reference/state/computed/#parameters","text":"callback: () -> any - a function which computes and returns the value to use for this computed object.","title":"Parameters"},{"location":"api-reference/state/computed/#object-methods","text":"","title":"Object Methods"},{"location":"api-reference/state/computed/#get","text":"function Computed : get (): any Returns the cached value of this computed object, as returned from the callback function. If dependencies are currently being detected (e.g. inside a computed callback), then this computed object will be used as a dependency.","title":"get()"},{"location":"api-reference/state/computed/#example-usage","text":"local numCoins = State ( 50 ) local doubleCoins = Computed ( function () return numCoins : get () * 2 end ) print ( doubleCoins : get ()) --> 100 numCoins : set ( 2 ) print ( doubleCoins : get ()) --> 4","title":"Example Usage"},{"location":"api-reference/state/computed/#dependency-management","text":"Computed objects automatically detect dependencies used inside their callback each time their callback runs. This means, when you use a function like :get() on a state object, it will register that state object as a dependency: local numCoins = State ( 50 ) local doubleCoins = Computed ( function () -- Fusion detects we called :get() on `numCoins`, and so adds `numCoins` as -- a dependency of this computed object. return numCoins : get () * 2 end ) When a dependency changes value, the computed object will re-run its callback to generate and cache the current value internally. This value is later exposed via the :get() method. Something to note is that dependencies are dynamic; you can change what values your computed object depends on, and the dependencies will be updated to reduce unnecessary updates: Lua Expected output local stateA = State ( 5 ) local stateB = State ( 5 ) local selector = State ( \"A\" ) local computed = Computed ( function () print ( \"> updating computed!\" ) local selected = selector : get () if selected == \"A\" then return stateA : get () elseif selected == \"B\" then return stateB : get () end end ) print ( \"increment state A (expect update below)\" ) stateA : set ( stateA : get () + 1 ) print ( \"increment state B (expect no update)\" ) stateA : set ( stateA : get () + 1 ) print ( \"switch to select B\" ) selector : set ( \"B\" ) print ( \"increment state A (expect no update)\" ) stateA : set ( stateA : get () + 1 ) print ( \"increment state B (expect update below)\" ) stateA : set ( stateA : get () + 1 ) > updating computed! increment state A (expect update below) > updating computed! increment state B (expect no update) switch to select B > updating computed! increment state A (expect no update) increment state B (expect update below) > updating computed! Danger Stick to using state objects and computed objects inside your computations. Fusion can detect when you use these objects and listen for changes. Fusion can't automatically detect changes when you use 'normal' variables: local theVariable = \"Hello\" local badValue = Computed ( function () -- don't do this! use state objects or computed objects in here return \"Say \" .. theVariable end ) print ( badValue : get ()) -- prints 'Say Hello' theVariable = \"World\" print ( badValue : get ()) -- still prints 'Say Hello' - that's a problem! By using a state object here, Fusion can correctly update the computed object, because it knows we used the state object: local theVariable = State ( \"Hello\" ) local goodValue = Computed ( function () -- this is much better - Fusion can detect we used this state object! return \"Say \" .. theVariable : get () end ) print ( goodValue : get ()) -- prints 'Say Hello' theVariable : set ( \"World\" ) print ( goodValue : get ()) -- prints 'Say World' This also applies to any functions that change on their own, like os.clock() . If you need to use them, store values from the function in a state object, and update the value of that object as often as required.","title":"Dependency Management"},{"location":"api-reference/state/computedpairs/","text":"function ComputedPairs ( inputTable : StateOrValue < {[ any ]: any } > , processor : ( key : any , value : any ) -> any , destructor : (( any ) -> any ) ? ): Computed Constructs and returns a new computed object, which generates a table by processing values from another table. The input table may be passed in directly, or inside a state object or computed object. The output table will have all the keys of the input table, but all the values will be passed through the processor function. When values are removed from the output table, they may optionally be passed through a destructor function. This allows you to properly clean up some types such as instances - more details can be found in the tutorial. Parameters \u00b6 inputTable: StateOrValue<{[any]: any}> - a table, or state object containing a table, which will be read by this ComputedPairs processor: (key: any, value: any) -> any - values from the input table will be passed through this function and placed in the table returned by this object destructor: ((any) -> any)? - when a value is removed from the output table, it will be passed to this function for cleanup. If not provided, defaults to a Maid-like cleanup function. Object Methods \u00b6 get() \u00b6 function ComputedPairs : get (): any Returns the cached value of this computed object, which will be the output table of key/value pairs. If dependencies are currently being detected (e.g. inside a computed callback), then this computed object will be used as a dependency. Example Usage \u00b6 local playerList = State ({ \"AxisAngles\" , \"boatbomber\" , \"Elttob\" , \"grilme99\" , \"Phalanxia\" , \"Reselim\" , \"thisfall\" }) local textLabels = ComputedPairs ( playerList , function ( key , value ) return New \"TextLabel\" { Text = value } end )","title":"Computedpairs"},{"location":"api-reference/state/computedpairs/#parameters","text":"inputTable: StateOrValue<{[any]: any}> - a table, or state object containing a table, which will be read by this ComputedPairs processor: (key: any, value: any) -> any - values from the input table will be passed through this function and placed in the table returned by this object destructor: ((any) -> any)? - when a value is removed from the output table, it will be passed to this function for cleanup. If not provided, defaults to a Maid-like cleanup function.","title":"Parameters"},{"location":"api-reference/state/computedpairs/#object-methods","text":"","title":"Object Methods"},{"location":"api-reference/state/computedpairs/#get","text":"function ComputedPairs : get (): any Returns the cached value of this computed object, which will be the output table of key/value pairs. If dependencies are currently being detected (e.g. inside a computed callback), then this computed object will be used as a dependency.","title":"get()"},{"location":"api-reference/state/computedpairs/#example-usage","text":"local playerList = State ({ \"AxisAngles\" , \"boatbomber\" , \"Elttob\" , \"grilme99\" , \"Phalanxia\" , \"Reselim\" , \"thisfall\" }) local textLabels = ComputedPairs ( playerList , function ( key , value ) return New \"TextLabel\" { Text = value } end )","title":"Example Usage"},{"location":"api-reference/state/dependency/","text":"Fusion State Dependency type since v0.1 \u00b6 A graph object which can send updates to dependents on the reactive graph. Most often used with state objects , though the reactive graph does not require objects to store state. { dependentSet : Set < Dependent > } Example Usage \u00b6 -- these are examples of objects which are dependencies local value : Dependency = Value ( 2 ) local computed : Dependency = Computed ( function () return value : get () * 2 end ) -- dependencies can be used with some internal functions such as updateAll() updateAll ( value ) Automatic Dependency Manager \u00b6 Fusion includes an automatic dependency manager which can detect when graph objects are used in certain contexts and automatically form reactive graphs. In order to do this, dependencies should signal to the system when they are being used (for example, during a call to a :get() method). This can be done via the useDependency() function internally, which should be called with the dependency object. Furthermore, to help assist the dependency manager prevent cycles in the reactive graph, dependencies should register themselves with the system as soon as they are created via the initDependency() function internally. This is primarily used to prevent dependencies from being captured when they originate from within the object which is doing the capturing.","title":"Dependency"},{"location":"api-reference/state/dependency/#dependency-type-since-v01","text":"A graph object which can send updates to dependents on the reactive graph. Most often used with state objects , though the reactive graph does not require objects to store state. { dependentSet : Set < Dependent > }","title":"\n    Dependency\n    \n        type\n        since v0.1\n    "},{"location":"api-reference/state/dependency/#example-usage","text":"-- these are examples of objects which are dependencies local value : Dependency = Value ( 2 ) local computed : Dependency = Computed ( function () return value : get () * 2 end ) -- dependencies can be used with some internal functions such as updateAll() updateAll ( value )","title":"Example Usage"},{"location":"api-reference/state/dependency/#automatic-dependency-manager","text":"Fusion includes an automatic dependency manager which can detect when graph objects are used in certain contexts and automatically form reactive graphs. In order to do this, dependencies should signal to the system when they are being used (for example, during a call to a :get() method). This can be done via the useDependency() function internally, which should be called with the dependency object. Furthermore, to help assist the dependency manager prevent cycles in the reactive graph, dependencies should register themselves with the system as soon as they are created via the initDependency() function internally. This is primarily used to prevent dependencies from being captured when they originate from within the object which is doing the capturing.","title":"Automatic Dependency Manager"},{"location":"api-reference/state/dependent/","text":"Fusion State Dependent type since v0.1 \u00b6 A graph object which can receive updates from dependecies on the reactive graph. Most often used with state objects , though the reactive graph does not require objects to store state. { dependencySet : Set < Dependency > , update : ( self ) -> boolean } Fields \u00b6 dependencySet - stores the graph objects which this object can receive updates from Methods \u00b6 since v0.1 Dependent:update() \u00b6 Called when this object receives an update from one or more dependencies. If this object is a dependency, and updates should be propagated to further dependencies, this method should return true. Otherwise, to block further updates from occuring (for example, because this object did not change value), this method should return false. () -> boolean Example Usage \u00b6 -- these are examples of objects which are dependents local computed : Dependent = Computed ( function () return \"foo\" end ) local observer : Dependent = Observer ( computed ) Automatic Dependency Manager \u00b6 Fusion includes an automatic dependency manager which can detect when graph objects are used in certain contexts and automatically form reactive graphs. If a dependent wants to automatically capture uses of dependencies inside of certain contexts (for example, a processor callback) then the captureDependencies() function may be invoked, with the callback and the object's dependency set as arguments. This will detect all useDependency() calls from inside the callback, and save any passed dependencies into the set.","title":"Dependent"},{"location":"api-reference/state/dependent/#dependent-type-since-v01","text":"A graph object which can receive updates from dependecies on the reactive graph. Most often used with state objects , though the reactive graph does not require objects to store state. { dependencySet : Set < Dependency > , update : ( self ) -> boolean }","title":"\n    Dependent\n    \n        type\n        since v0.1\n    "},{"location":"api-reference/state/dependent/#fields","text":"dependencySet - stores the graph objects which this object can receive updates from","title":"Fields"},{"location":"api-reference/state/dependent/#methods","text":"since v0.1","title":"Methods"},{"location":"api-reference/state/dependent/#dependentupdate","text":"Called when this object receives an update from one or more dependencies. If this object is a dependency, and updates should be propagated to further dependencies, this method should return true. Otherwise, to block further updates from occuring (for example, because this object did not change value), this method should return false. () -> boolean","title":" Dependent:update()"},{"location":"api-reference/state/dependent/#example-usage","text":"-- these are examples of objects which are dependents local computed : Dependent = Computed ( function () return \"foo\" end ) local observer : Dependent = Observer ( computed )","title":"Example Usage"},{"location":"api-reference/state/dependent/#automatic-dependency-manager","text":"Fusion includes an automatic dependency manager which can detect when graph objects are used in certain contexts and automatically form reactive graphs. If a dependent wants to automatically capture uses of dependencies inside of certain contexts (for example, a processor callback) then the captureDependencies() function may be invoked, with the callback and the object's dependency set as arguments. This will detect all useDependency() calls from inside the callback, and save any passed dependencies into the set.","title":"Automatic Dependency Manager"},{"location":"api-reference/state/state/","text":"function State ( initialValue : any ? ): State Constructs and returns a new state object, with an optional initial value. Parameters \u00b6 initialValue: any? - the value which should initially be stored in the state object. Object Methods \u00b6 get() \u00b6 function State : get (): any Returns the currently stored value of this state object. If dependencies are currently being detected (e.g. inside a computed callback), then this state object will be used as a dependency. set() \u00b6 function State : set ( newValue : any , force : boolean ? ) Sets the new value of this state object. If the new and old values differ, this will update any other objects using this state object. However, if they're the same, no update will be performed. Force updating If you want to override this behaviour, you can set force to true . This will ensure updates are always performed, even if the new and old values are the same (as measured by the == operator). This is most useful when working with mutable tables. However, be very careful with this, and only force updates when you need to for performance reasons. Try a solution involving immutable tables first. Abuse of force updating can lead to suboptimal code that updates redundantly. Example Usage \u00b6 local numCoins = State ( 50 ) print ( numCoins : get ()) --> 50 numCoins : set ( 25 ) print ( numCoins : get ()) --> 25 numCoins . onChange : Connect ( function () print ( \"Coins changed to:\" , numCoins : get ()) end )","title":"State"},{"location":"api-reference/state/state/#parameters","text":"initialValue: any? - the value which should initially be stored in the state object.","title":"Parameters"},{"location":"api-reference/state/state/#object-methods","text":"","title":"Object Methods"},{"location":"api-reference/state/state/#get","text":"function State : get (): any Returns the currently stored value of this state object. If dependencies are currently being detected (e.g. inside a computed callback), then this state object will be used as a dependency.","title":"get()"},{"location":"api-reference/state/state/#set","text":"function State : set ( newValue : any , force : boolean ? ) Sets the new value of this state object. If the new and old values differ, this will update any other objects using this state object. However, if they're the same, no update will be performed. Force updating If you want to override this behaviour, you can set force to true . This will ensure updates are always performed, even if the new and old values are the same (as measured by the == operator). This is most useful when working with mutable tables. However, be very careful with this, and only force updates when you need to for performance reasons. Try a solution involving immutable tables first. Abuse of force updating can lead to suboptimal code that updates redundantly.","title":"set()"},{"location":"api-reference/state/state/#example-usage","text":"local numCoins = State ( 50 ) print ( numCoins : get ()) --> 50 numCoins : set ( 25 ) print ( numCoins : get ()) --> 25 numCoins . onChange : Connect ( function () print ( \"Coins changed to:\" , numCoins : get ()) end )","title":"Example Usage"},{"location":"api-reference/state/stateobject/","text":"Fusion State Dependent type since v0.1 \u00b6 A graph object which can receive updates from dependecies on the reactive graph. Most often used with state objects , though the reactive graph does not require objects to store state. { dependencySet : Set < Dependency > , update : ( self ) -> boolean } Fields \u00b6 dependencySet - stores the graph objects which this object can receive updates from Methods \u00b6 since v0.1 Dependent:update() \u00b6 Called when this object receives an update from one or more dependencies. If this object is a dependency, and updates should be propagated to further dependencies, this method should return true. Otherwise, to block further updates from occuring (for example, because this object did not change value), this method should return false. () -> boolean Example Usage \u00b6 -- these are examples of objects which are dependents local computed : Dependent = Computed ( function () return \"foo\" end ) local observer : Dependent = Observer ( computed ) Automatic Dependency Manager \u00b6 Fusion includes an automatic dependency manager which can detect when graph objects are used in certain contexts and automatically form reactive graphs. If a dependent wants to automatically capture uses of dependencies inside of certain contexts (for example, a processor callback) then the captureDependencies() function may be invoked, with the callback and the object's dependency set as arguments. This will detect all useDependency() calls from inside the callback, and save any passed dependencies into the set.","title":"StateObject"},{"location":"api-reference/state/stateobject/#dependent-type-since-v01","text":"A graph object which can receive updates from dependecies on the reactive graph. Most often used with state objects , though the reactive graph does not require objects to store state. { dependencySet : Set < Dependency > , update : ( self ) -> boolean }","title":"\n    Dependent\n    \n        type\n        since v0.1\n    "},{"location":"api-reference/state/stateobject/#fields","text":"dependencySet - stores the graph objects which this object can receive updates from","title":"Fields"},{"location":"api-reference/state/stateobject/#methods","text":"since v0.1","title":"Methods"},{"location":"api-reference/state/stateobject/#dependentupdate","text":"Called when this object receives an update from one or more dependencies. If this object is a dependency, and updates should be propagated to further dependencies, this method should return true. Otherwise, to block further updates from occuring (for example, because this object did not change value), this method should return false. () -> boolean","title":" Dependent:update()"},{"location":"api-reference/state/stateobject/#example-usage","text":"-- these are examples of objects which are dependents local computed : Dependent = Computed ( function () return \"foo\" end ) local observer : Dependent = Observer ( computed )","title":"Example Usage"},{"location":"api-reference/state/stateobject/#automatic-dependency-manager","text":"Fusion includes an automatic dependency manager which can detect when graph objects are used in certain contexts and automatically form reactive graphs. If a dependent wants to automatically capture uses of dependencies inside of certain contexts (for example, a processor callback) then the captureDependencies() function may be invoked, with the callback and the object's dependency set as arguments. This will detect all useDependency() calls from inside the callback, and save any passed dependencies into the set.","title":"Automatic Dependency Manager"},{"location":"examples/","text":"Examples \u00b6 Welcome to the Examples section! Here, you can find various open-source examples and projects, so you can see how Fusion works in a real setting. The Cookbook \u00b6 Oftentimes, you might be stuck on a small problem. You want to create something specific, but don't know how to do it with Fusion's tools. The cookbook can help with that! It's a collection of snippets which show you how to do various small tasks with Fusion, like processing arrays, applying animations and responding to different events. Visit the cookbook to see what's available. Open-Source Projects \u00b6 Fusion Wordle \u00b6 See how Fusion can be used to build a mobile-first UI-centric game, with server validation, spring animations and sounds. Play and edit the game on Roblox. Fusion Obby \u00b6 See how Fusion can be used to build a minimal interface for an obby, with an animated checkpoint counter and simulated confetti. Play and edit the game on Roblox.","title":"Home"},{"location":"examples/#examples","text":"Welcome to the Examples section! Here, you can find various open-source examples and projects, so you can see how Fusion works in a real setting.","title":"Examples"},{"location":"examples/#the-cookbook","text":"Oftentimes, you might be stuck on a small problem. You want to create something specific, but don't know how to do it with Fusion's tools. The cookbook can help with that! It's a collection of snippets which show you how to do various small tasks with Fusion, like processing arrays, applying animations and responding to different events. Visit the cookbook to see what's available.","title":"The Cookbook"},{"location":"examples/#open-source-projects","text":"","title":"Open-Source Projects"},{"location":"examples/#fusion-wordle","text":"See how Fusion can be used to build a mobile-first UI-centric game, with server validation, spring animations and sounds. Play and edit the game on Roblox.","title":"Fusion Wordle"},{"location":"examples/#fusion-obby","text":"See how Fusion can be used to build a minimal interface for an obby, with an animated checkpoint counter and simulated confetti. Play and edit the game on Roblox.","title":"Fusion Obby"},{"location":"extras/","text":"Extras \u00b6 Welcome to the Extras section! Here, you can find guidelines and assets for Fusion branding, download backgrounds and wallpapers for your devices, and more! Commonly Used \u00b6 Backgrounds Brand Guidelines","title":"Home"},{"location":"extras/#extras","text":"Welcome to the Extras section! Here, you can find guidelines and assets for Fusion branding, download backgrounds and wallpapers for your devices, and more!","title":"Extras"},{"location":"extras/#commonly-used","text":"Backgrounds Brand Guidelines","title":"Commonly Used"},{"location":"extras/backgrounds/","text":"All backgrounds are PNG format, and have been optimised for these resolutions: Ultrawide (7680 x 1440) Widescreen (2560 x 1440) 3:2 (2256 x 1504) Mobile (1125 x 2436) These backgrounds are intended for personal use only! These backgrounds are, and remain, the copyright of Elttob. You may not use these, commercially or otherwise, without explicit written consent. Isosceles \u00b6 A pattern of isosceles triangles distributed along the bottom, with the Fusion gradient. Background is hex colour #1D1D1F, and so might not be ideal for OLED screens. Ultrawide Widescreen 3:2 Mobile Extrusion \u00b6 A Fusion logo, with extruded fill lines coming out of the logo. Background is hex colour #0D0D0F, and so might not be ideal for OLED screens. Ultrawide Widescreen 3:2 Mobile Construction \u00b6 The Fusion logo, with construction lines shown and other geometric patterns. Background is 100% black, ideal for OLED screens. Ultrawide Widescreen 3:2 Mobile Glow \u00b6 A centred Fusion logo emitting light on a dark background. Background is 100% black, ideal for OLED screens. Ultrawide Widescreen 3:2 Mobile Glow (Alternate) \u00b6 A centred Fusion logo emitting light on a dark background. Uses an alternate design of the logo, which is now used for livestreams. Background is 100% black, ideal for OLED screens. Ultrawide Widescreen 3:2 Mobile","title":"Backgrounds"},{"location":"extras/backgrounds/#isosceles","text":"A pattern of isosceles triangles distributed along the bottom, with the Fusion gradient. Background is hex colour #1D1D1F, and so might not be ideal for OLED screens. Ultrawide Widescreen 3:2 Mobile","title":"Isosceles"},{"location":"extras/backgrounds/#extrusion","text":"A Fusion logo, with extruded fill lines coming out of the logo. Background is hex colour #0D0D0F, and so might not be ideal for OLED screens. Ultrawide Widescreen 3:2 Mobile","title":"Extrusion"},{"location":"extras/backgrounds/#construction","text":"The Fusion logo, with construction lines shown and other geometric patterns. Background is 100% black, ideal for OLED screens. Ultrawide Widescreen 3:2 Mobile","title":"Construction"},{"location":"extras/backgrounds/#glow","text":"A centred Fusion logo emitting light on a dark background. Background is 100% black, ideal for OLED screens. Ultrawide Widescreen 3:2 Mobile","title":"Glow"},{"location":"extras/backgrounds/#glow-alternate","text":"A centred Fusion logo emitting light on a dark background. Uses an alternate design of the logo, which is now used for livestreams. Background is 100% black, ideal for OLED screens. Ultrawide Widescreen 3:2 Mobile","title":"Glow (Alternate)"},{"location":"extras/brand-guidelines/","text":"The Fusion branding is designed to be simplistic, modern, easy to recognise and distinctive. Colours \u00b6 Primaries \u00b6 These colours are used in the Fusion logo and most illustrations. They might not be suitable for text or all backgrounds. FusionDoc greys \u00b6 These colours are used by the FusionDoc theme on this website for all grey tones used on pages. FusionDoc accents \u00b6 These colours are used by the FusionDoc theme on this website for accent colours on links and interactive elements. Best Practices \u00b6 We would love you to use the Fusion branding in your own work, but please be mindful that you use it appropriately. If you're not sure, feel free to reach out over Discord or Twitter - it's always better to ask first to be secure! These aren't hard and fast rules, and we can't and don't want to police how people use our stuff. Instead, these are provided as best practices to follow. We'll add any common examples or questions to this list over time. Brand Confusion \u00b6 Fusion's logo and name are designed to represent Fusion's official projects. Please don't use them to represent things that are not Fusion; for example, if you build your own UI library, it's better to design a new logo. In general, prefer to keep some distance between your project branding and Fusion's branding, enough distance that people don't get confused about who makes what, or whether a project is officially supported or not. It's a good litmus test to imagine a first-time user who knows nothing about Fusion, and how they will perceive your project. Don't do this In this example, someone made their own UI library and named it Fusion 2. Note that this is an extreme example for demonstration purposes - most violations of this principle are probably more subtle. This is bad because people might mistakenly think the official Fusion project approves or provides support for this unrelated project, which would cause many headaches and is dishonest about the relationship between the two libraries. Plus, in this example, we reserve the right to update Fusion to version 2 at any time, which would immediately cause a naming conflict. Instead, do this This logo makes it more clear that the project is not a port of, update to or bindings for the Fusion library. Instead, it's a completely distinct project which only takes inspiration from Fusion, but is otherwise unrelated. It's okay for the logo to remind people of Fusion's design. Remember - you don't have to be completely original, just distinct enough that it isn't confusing for people. Acceptable, but be careful Here, this plugin is using the Fusion logo to represent a 'Convert to Fusion' action. This is fine, because users will understand the Fusion logo represents the thing being converted to. However, be careful, as free-standing uses of the Fusion icon like this can easily become confusing. Make sure people understand the logo represents Fusion, and not the plugin, so confusion between the two is minimised.","title":"Brand Guidelines"},{"location":"extras/brand-guidelines/#colours","text":"","title":"Colours"},{"location":"extras/brand-guidelines/#primaries","text":"These colours are used in the Fusion logo and most illustrations. They might not be suitable for text or all backgrounds.","title":"Primaries"},{"location":"extras/brand-guidelines/#fusiondoc-greys","text":"These colours are used by the FusionDoc theme on this website for all grey tones used on pages.","title":"FusionDoc greys"},{"location":"extras/brand-guidelines/#fusiondoc-accents","text":"These colours are used by the FusionDoc theme on this website for accent colours on links and interactive elements.","title":"FusionDoc accents"},{"location":"extras/brand-guidelines/#best-practices","text":"We would love you to use the Fusion branding in your own work, but please be mindful that you use it appropriately. If you're not sure, feel free to reach out over Discord or Twitter - it's always better to ask first to be secure! These aren't hard and fast rules, and we can't and don't want to police how people use our stuff. Instead, these are provided as best practices to follow. We'll add any common examples or questions to this list over time.","title":"Best Practices"},{"location":"extras/brand-guidelines/#brand-confusion","text":"Fusion's logo and name are designed to represent Fusion's official projects. Please don't use them to represent things that are not Fusion; for example, if you build your own UI library, it's better to design a new logo. In general, prefer to keep some distance between your project branding and Fusion's branding, enough distance that people don't get confused about who makes what, or whether a project is officially supported or not. It's a good litmus test to imagine a first-time user who knows nothing about Fusion, and how they will perceive your project. Don't do this In this example, someone made their own UI library and named it Fusion 2. Note that this is an extreme example for demonstration purposes - most violations of this principle are probably more subtle. This is bad because people might mistakenly think the official Fusion project approves or provides support for this unrelated project, which would cause many headaches and is dishonest about the relationship between the two libraries. Plus, in this example, we reserve the right to update Fusion to version 2 at any time, which would immediately cause a naming conflict. Instead, do this This logo makes it more clear that the project is not a port of, update to or bindings for the Fusion library. Instead, it's a completely distinct project which only takes inspiration from Fusion, but is otherwise unrelated. It's okay for the logo to remind people of Fusion's design. Remember - you don't have to be completely original, just distinct enough that it isn't confusing for people. Acceptable, but be careful Here, this plugin is using the Fusion logo to represent a 'Convert to Fusion' action. This is fine, because users will understand the Fusion logo represents the thing being converted to. However, be careful, as free-standing uses of the Fusion icon like this can easily become confusing. Make sure people understand the logo represents Fusion, and not the plugin, so confusion between the two is minimised.","title":"Brand Confusion"},{"location":"tutorials/","text":"Welcome to the Fusion tutorial section! Here, you'll learn how to build great interfaces with Fusion, even if you're a complete newcomer to the library. But first, something important... Do not use Fusion for real-world production work unless you're 100,000% willing and able to withstand large breaking changes. Fusion is in very early beta right now! You will encounter: bugs in core features updates that completely remove existing features changes in behaviour between versions changing advice on coding conventions and how to structure your project This is not a bad thing! Moving fast with Fusion at this early stage means we can quickly abandon counterproductive ideas and features, and discover much more solid foundations to build upon. Don't be discouraged from Fusion though; feel free to follow along with our development and try using the library in your own time! More stable, long-term Fusion versions will be available once Fusion exits beta testing. What You Need To Know \u00b6 These tutorials assume: You're comfortable with Roblox and the Luau scripting language. These tutorials aren't an introduction to scripting! If you'd like to learn, check out the Roblox DevHub . You're familiar with how UI works on Roblox. You don't have to be a designer - knowing about UI instances, events and data types like UDim2 and Color3 will be good enough. Of course, based on your existing knowledge, you may find some tutorials easier or harder. Fusion's built to be easy to learn, but it may still take a bit of time to absorb some concepts, so don't be discouraged Installing Fusion \u00b6 Fusion is distributed as a single module script. Before starting, you'll need to add this module script to your game. Here's how: If you edit scripts in Roblox Studio... \u00b6 Head over to Fusion's 'Releases' page . Click the 'Assets' dropdown to view the downloadable files: Now, click on the Fusion.rbxm file to download it. This contains the module as a Roblox model: Head into Roblox Studio to import the model; if you're just following the tutorials, an empty baseplate will do. Right-click on ReplicatedStorage , and select 'Insert from File': Select the Fusion.rbxm file you just downloaded. You should see the module script appear in ReplicatedStorage - you're ready to go! If you edit scripts externally... (advanced) \u00b6 If you use an external editor to write scripts, and synchronise them into Roblox using a plugin, you can use these alternate steps instead: Steps (click to expand) Head over to Fusion's 'Releases' page . Under 'Assets', download Source code (zip) . Inside is a copy of the Fusion GitHub repository. Inside the zip, copy the src folder - it may be inside another folder. Paste src into your local project, preferably in your shared folder if you have one. Rename the folder from src to Fusion . Once everything is set up, you should see Fusion appear in Studio when you next synchronise your project. Setting Up A Test Script \u00b6 Now that you've installed Fusion, you can set up a local script for testing. Here's how: Create a LocalScript in StarterGui or StarterPlayerScripts . Remove the default code, and paste the following code in: 1 2 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) Press 'Play' - if there are no errors, everything was set up correctly! My script didn't work! (click to expand) Fusion is not a valid member of ReplicatedStorage \"ReplicatedStorage\" If you're seeing this error, then your script can't find Fusion. This code assumes you've installed Fusion into ReplicatedStorage . If you've installed Fusion elsewhere, you'll need to tweak the require() on line 2 to point to the correct location. If line 2 looks like it points to the correct location, refer back to the previous section and double-check you've set everything up properly. Make sure you have a ModuleScript inside ReplicatedStorage called \"Fusion\". Where To Get Help \u00b6 Fusion is built to be easy to use, and we want these tutorials to be as useful and comprehensive as possible. However, maybe you're stuck on a cursed issue and really need some help; or perhaps you're looking to get a better overall understanding of Fusion! Whatever you're looking for, here are some resources for you to get help: The Roblox OSS Discord has a #fusion channel Check out our Discussions page on GitHub Open an issue if you run into bugs or have feature requests","title":"Get Started"},{"location":"tutorials/#what-you-need-to-know","text":"These tutorials assume: You're comfortable with Roblox and the Luau scripting language. These tutorials aren't an introduction to scripting! If you'd like to learn, check out the Roblox DevHub . You're familiar with how UI works on Roblox. You don't have to be a designer - knowing about UI instances, events and data types like UDim2 and Color3 will be good enough. Of course, based on your existing knowledge, you may find some tutorials easier or harder. Fusion's built to be easy to learn, but it may still take a bit of time to absorb some concepts, so don't be discouraged","title":"What You Need To Know"},{"location":"tutorials/#installing-fusion","text":"Fusion is distributed as a single module script. Before starting, you'll need to add this module script to your game. Here's how:","title":"Installing Fusion"},{"location":"tutorials/#if-you-edit-scripts-in-roblox-studio","text":"Head over to Fusion's 'Releases' page . Click the 'Assets' dropdown to view the downloadable files: Now, click on the Fusion.rbxm file to download it. This contains the module as a Roblox model: Head into Roblox Studio to import the model; if you're just following the tutorials, an empty baseplate will do. Right-click on ReplicatedStorage , and select 'Insert from File': Select the Fusion.rbxm file you just downloaded. You should see the module script appear in ReplicatedStorage - you're ready to go!","title":"If you edit scripts in Roblox Studio..."},{"location":"tutorials/#if-you-edit-scripts-externally-advanced","text":"If you use an external editor to write scripts, and synchronise them into Roblox using a plugin, you can use these alternate steps instead: Steps (click to expand) Head over to Fusion's 'Releases' page . Under 'Assets', download Source code (zip) . Inside is a copy of the Fusion GitHub repository. Inside the zip, copy the src folder - it may be inside another folder. Paste src into your local project, preferably in your shared folder if you have one. Rename the folder from src to Fusion . Once everything is set up, you should see Fusion appear in Studio when you next synchronise your project.","title":"If you edit scripts externally... (advanced)"},{"location":"tutorials/#setting-up-a-test-script","text":"Now that you've installed Fusion, you can set up a local script for testing. Here's how: Create a LocalScript in StarterGui or StarterPlayerScripts . Remove the default code, and paste the following code in: 1 2 local ReplicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local Fusion = require ( ReplicatedStorage . Fusion ) Press 'Play' - if there are no errors, everything was set up correctly! My script didn't work! (click to expand) Fusion is not a valid member of ReplicatedStorage \"ReplicatedStorage\" If you're seeing this error, then your script can't find Fusion. This code assumes you've installed Fusion into ReplicatedStorage . If you've installed Fusion elsewhere, you'll need to tweak the require() on line 2 to point to the correct location. If line 2 looks like it points to the correct location, refer back to the previous section and double-check you've set everything up properly. Make sure you have a ModuleScript inside ReplicatedStorage called \"Fusion\".","title":"Setting Up A Test Script"},{"location":"tutorials/#where-to-get-help","text":"Fusion is built to be easy to use, and we want these tutorials to be as useful and comprehensive as possible. However, maybe you're stuck on a cursed issue and really need some help; or perhaps you're looking to get a better overall understanding of Fusion! Whatever you're looking for, here are some resources for you to get help: The Roblox OSS Discord has a #fusion channel Check out our Discussions page on GitHub Open an issue if you run into bugs or have feature requests","title":"Where To Get Help"},{"location":"tutorials/components/parenting/","text":"TODO Returning Children \u00b6 As we saw in the previous section, components can return instances: local function Button ( props ) return New \"TextButton\" { BackgroundColor3 = Color3 . new ( 0 , 0.25 , 1 ), Position = props . Position , AnchorPoint = props . AnchorPoint , Size = props . Size , LayoutOrder = props . LayoutOrder , Text = props . ButtonText , TextSize = 28 , TextColor3 = Color3 . new ( 1 , 1 , 1 ), [ Children ] = UICorner { CornerRadius = UDim2 . new ( 0 , 8 ) } } end We can call this function later to generate as many buttons as we need: -- this is just a regular Lua function call! local helloBtn = Button { ButtonText = \"Hello\" , Size = UDim2 . fromOffset ( 200 , 50 ) } helloBtn . Parent = Players . LocalPlayer . PlayerGui . ScreenGui This is the primary way UI is reused in Fusion, and it's significant enough to have it's own name. Any function that takes in props and returns instances is called a component (because it often represents a reusable component of an interface). Tip They're so significant, in fact, that you've already been using components without knowing it! local makeTextLabel = New ( \"TextLabel\" ) print ( typeof ( makeTextLabel )) --> function local myLabel = makeTextLabel { Text = \"Hello, world!\" } When you call New with a class name, it returns a component. Calling the component will create a new instance of that class type, using the props as properties to apply to the instance.","title":"Parenting"},{"location":"tutorials/components/parenting/#returning-children","text":"As we saw in the previous section, components can return instances: local function Button ( props ) return New \"TextButton\" { BackgroundColor3 = Color3 . new ( 0 , 0.25 , 1 ), Position = props . Position , AnchorPoint = props . AnchorPoint , Size = props . Size , LayoutOrder = props . LayoutOrder , Text = props . ButtonText , TextSize = 28 , TextColor3 = Color3 . new ( 1 , 1 , 1 ), [ Children ] = UICorner { CornerRadius = UDim2 . new ( 0 , 8 ) } } end We can call this function later to generate as many buttons as we need: -- this is just a regular Lua function call! local helloBtn = Button { ButtonText = \"Hello\" , Size = UDim2 . fromOffset ( 200 , 50 ) } helloBtn . Parent = Players . LocalPlayer . PlayerGui . ScreenGui This is the primary way UI is reused in Fusion, and it's significant enough to have it's own name. Any function that takes in props and returns instances is called a component (because it often represents a reusable component of an interface). Tip They're so significant, in fact, that you've already been using components without knowing it! local makeTextLabel = New ( \"TextLabel\" ) print ( typeof ( makeTextLabel )) --> function local myLabel = makeTextLabel { Text = \"Hello, world!\" } When you call New with a class name, it returns a component. Calling the component will create a new instance of that class type, using the props as properties to apply to the instance.","title":"Returning Children"},{"location":"tutorials/components/reusing-ui/","text":"Up until this point, we have been creating and parenting instances directly to the data model without much organisation or code reuse. However, those two factors will become increasingly important as you start building more game-ready UIs. These next few pages won't introduce new features of Fusion, but instead will focus on techniques for making your UI more modular, portable and easy to maintain. The Component Pattern \u00b6 One of the greatest advantages of libraries like Fusion is that UI and code are the same thing. Any tool that we can use on one, we can use on the other. To reduce repetition in our codebases, we often use functions to run small reusable blocks of code, sometimes with parameters we can change. We can use functions to organise our UI code, too. For example, consider this function, which generates a button based on some props the user passes in: local function Button ( props ) return New \"TextButton\" { BackgroundColor3 = Color3 . new ( 0 , 0.25 , 1 ), Position = props . Position , AnchorPoint = props . AnchorPoint , Size = props . Size , LayoutOrder = props . LayoutOrder , Text = props . ButtonText , TextSize = 28 , TextColor3 = Color3 . new ( 1 , 1 , 1 ), [ Children ] = UICorner { CornerRadius = UDim2 . new ( 0 , 8 ) } } end We can call this function later to generate as many buttons as we need: -- this is just a regular Lua function call! local helloBtn = Button { ButtonText = \"Hello\" , Size = UDim2 . fromOffset ( 200 , 50 ) } helloBtn . Parent = Players . LocalPlayer . PlayerGui . ScreenGui This is the primary way UI is reused in Fusion, and it's significant enough to have it's own name. Any function that takes in props and returns instances is called a component (because it often represents a reusable component of an interface). Tip They're so significant, in fact, that you've already been using components without knowing it! local makeTextLabel = New ( \"TextLabel\" ) print ( typeof ( makeTextLabel )) --> function local myLabel = makeTextLabel { Text = \"Hello, world!\" } When you call New with a class name, it returns a component. Calling the component will create a new instance of that class type, using the props as properties to apply to the instance.","title":"Reusing UI"},{"location":"tutorials/components/reusing-ui/#the-component-pattern","text":"One of the greatest advantages of libraries like Fusion is that UI and code are the same thing. Any tool that we can use on one, we can use on the other. To reduce repetition in our codebases, we often use functions to run small reusable blocks of code, sometimes with parameters we can change. We can use functions to organise our UI code, too. For example, consider this function, which generates a button based on some props the user passes in: local function Button ( props ) return New \"TextButton\" { BackgroundColor3 = Color3 . new ( 0 , 0.25 , 1 ), Position = props . Position , AnchorPoint = props . AnchorPoint , Size = props . Size , LayoutOrder = props . LayoutOrder , Text = props . ButtonText , TextSize = 28 , TextColor3 = Color3 . new ( 1 , 1 , 1 ), [ Children ] = UICorner { CornerRadius = UDim2 . new ( 0 , 8 ) } } end We can call this function later to generate as many buttons as we need: -- this is just a regular Lua function call! local helloBtn = Button { ButtonText = \"Hello\" , Size = UDim2 . fromOffset ( 200 , 50 ) } helloBtn . Parent = Players . LocalPlayer . PlayerGui . ScreenGui This is the primary way UI is reused in Fusion, and it's significant enough to have it's own name. Any function that takes in props and returns instances is called a component (because it often represents a reusable component of an interface). Tip They're so significant, in fact, that you've already been using components without knowing it! local makeTextLabel = New ( \"TextLabel\" ) print ( typeof ( makeTextLabel )) --> function local myLabel = makeTextLabel { Text = \"Hello, world!\" } When you call New with a class name, it returns a component. Calling the component will create a new instance of that class type, using the props as properties to apply to the instance.","title":"The Component Pattern"},{"location":"tutorials/fundamentals/computeds/","text":"Computeds are state objects that can process values from other state objects. You pass in a callback which calculates the final value. Then, you can use :get() to retrieve that value at any time. local numCoins = Value ( 50 ) local itemPrice = Value ( 10 ) local finalCoins = Computed ( function () return numCoins : get () - itemPrice : get () end ) print ( finalCoins : get ()) --> 40 numCoins : set ( 25 ) itemPrice : set ( 15 ) print ( finalCoins : get ()) --> 10 Usage \u00b6 To use Computed in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local Computed = Fusion . Computed To create a new computed object, call the Computed function and pass it a callback returning a single value: local hardMaths = Computed ( function () return 1 + 1 end ) The value your callback returns will be stored as the computed's value. You can get the computed's current value using :get() : print ( hardMaths : get ()) --> 2 By default, a computed only runs its callback once. However, Fusion can detect any time you call :get() on a state object inside the callback. If any of them change value, the callback will be re-run and the value will update: local number = Value ( 2 ) local double = Computed ( function () return number : get () * 2 end ) print ( number : get (), \"* 2 =\" , double : get ()) --> 2 * 2 = 4 number : set ( 10 ) print ( number : get (), \"* 2 =\" , double : get ()) --> 10 * 2 = 20 number : set ( - 5 ) print ( number : get (), \"* 2 =\" , double : get ()) --> -5 * 2 = -10 When To Use This \u00b6 Computeds are more specialist than regular values and observers. They're designed for a single purpose: they make it easier and more efficient to derive new values from existing state objects. Derived values show up in a lot of places throughout UIs. For example, you might want to insert a death counter into a string. Therefore, the contents of the string are derived from the death counter: While you can do this with values and observers alone, your code could get messy. Consider the following code that doesn't use computeds - the intent is to create a derived value, finalCoins , which equals numCoins - itemPrice at all times: 1 2 3 4 5 6 7 8 9 local numCoins = Value ( 50 ) local itemPrice = Value ( 10 ) local finalCoins = Value ( numCoins : get () - itemPrice : get ()) local function updateFinalCoins () finalCoins : set ( numCoins : get () - itemPrice : get ()) end Observer ( numCoins ): onChange ( updateFinalCoins ) Observer ( itemPrice ): onChange ( updateFinalCoins ) There are a few problems with this code currently: It's not immediately clear what's happening at a glance; there's lots of boilerplate code obscuring what the intent of the code is. The logic for calculating finalCoins is duplicated twice - on lines 4 and 6. You have to manage updating the value yourself using observers. This is an easy place for desynchronisation bugs to slip in. Another part of the code base could call finalCoins:set() and mess with the value. When written with computeds, the above problems are largely solved: 1 2 3 4 5 6 local numCoins = Value ( 50 ) local itemPrice = Value ( 10 ) local finalCoins = Computed ( function () return numCoins : get () - itemPrice : get () end ) The intent is immediately clear - this is a derived value. The logic is only specified once, in one callback. The computed updates itself when a state object you :get() changes value. The callback is the only thing that can change the value - there is no :set() method. A warning about delays in computed callbacks One small caveat of computeds is that you must return the value immediately. If you need to send a request to the server or perform a long-running calculation, you shouldn't use computeds. The reason for this is consistency between variables. When all computeds run immediately (i.e. without yielding), all of your variables will behave consistently: local numCoins = Value ( 50 ) local isEnoughCoins = Computed ( function () return numCoins : get () > 25 end ) local message = Computed ( function () if isEnoughCoins : get () then return numCoins : get () .. \" is enough coins.\" else return numCoins : get () .. \" is NOT enough coins.\" end end ) print ( message : get ()) --> 50 is enough coins. numCoins : set ( 2 ) print ( message : get ()) --> 2 is NOT enough coins. If a delay is introduced, then inconsistencies and nonsense values could quickly appear: local numCoins = Value ( 50 ) local isEnoughCoins = Computed ( function () wait ( 5 ) -- Don't do this! This is just for the example return numCoins : get () > 25 end ) local message = Computed ( function () if isEnoughCoins : get () then return numCoins : get () .. \" is enough coins.\" else return numCoins : get () .. \" is NOT enough coins.\" end end ) print ( message : get ()) --> 50 is enough coins. numCoins : set ( 2 ) print ( message : get ()) --> 2 is enough coins. For this reason, yielding in computed callbacks is disallowed. If you have to introduce a delay, for example when invoking a RemoteFunction, consider using values and observers. local numCoins = Value ( 50 ) local isEnoughCoins = Value ( nil ) local function updateIsEnoughCoins () isEnoughCoins : set ( nil ) -- indicate that we're calculating the value wait ( 5 ) -- this is now ok isEnoughCoins : set ( numCoins : get () > 25 ) end task . spawn ( updateIsEnoughCoins ) Observer ( numCoins ): onChange ( updateIsEnoughCoins ) local message = Computed ( function () if isEnoughCoins : get () == nil then return \"Loading...\" elseif isEnoughCoins : get () then return numCoins : get () .. \" is enough coins.\" else return numCoins : get () .. \" is NOT enough coins.\" end end ) print ( message : get ()) --> 50 is enough coins. numCoins : set ( 2 ) print ( message : get ()) --> Loading... wait ( 5 ) print ( message : get ()) --> 2 is NOT enough coins.","title":"Computeds"},{"location":"tutorials/fundamentals/computeds/#usage","text":"To use Computed in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local Computed = Fusion . Computed To create a new computed object, call the Computed function and pass it a callback returning a single value: local hardMaths = Computed ( function () return 1 + 1 end ) The value your callback returns will be stored as the computed's value. You can get the computed's current value using :get() : print ( hardMaths : get ()) --> 2 By default, a computed only runs its callback once. However, Fusion can detect any time you call :get() on a state object inside the callback. If any of them change value, the callback will be re-run and the value will update: local number = Value ( 2 ) local double = Computed ( function () return number : get () * 2 end ) print ( number : get (), \"* 2 =\" , double : get ()) --> 2 * 2 = 4 number : set ( 10 ) print ( number : get (), \"* 2 =\" , double : get ()) --> 10 * 2 = 20 number : set ( - 5 ) print ( number : get (), \"* 2 =\" , double : get ()) --> -5 * 2 = -10","title":"Usage"},{"location":"tutorials/fundamentals/computeds/#when-to-use-this","text":"Computeds are more specialist than regular values and observers. They're designed for a single purpose: they make it easier and more efficient to derive new values from existing state objects. Derived values show up in a lot of places throughout UIs. For example, you might want to insert a death counter into a string. Therefore, the contents of the string are derived from the death counter: While you can do this with values and observers alone, your code could get messy. Consider the following code that doesn't use computeds - the intent is to create a derived value, finalCoins , which equals numCoins - itemPrice at all times: 1 2 3 4 5 6 7 8 9 local numCoins = Value ( 50 ) local itemPrice = Value ( 10 ) local finalCoins = Value ( numCoins : get () - itemPrice : get ()) local function updateFinalCoins () finalCoins : set ( numCoins : get () - itemPrice : get ()) end Observer ( numCoins ): onChange ( updateFinalCoins ) Observer ( itemPrice ): onChange ( updateFinalCoins ) There are a few problems with this code currently: It's not immediately clear what's happening at a glance; there's lots of boilerplate code obscuring what the intent of the code is. The logic for calculating finalCoins is duplicated twice - on lines 4 and 6. You have to manage updating the value yourself using observers. This is an easy place for desynchronisation bugs to slip in. Another part of the code base could call finalCoins:set() and mess with the value. When written with computeds, the above problems are largely solved: 1 2 3 4 5 6 local numCoins = Value ( 50 ) local itemPrice = Value ( 10 ) local finalCoins = Computed ( function () return numCoins : get () - itemPrice : get () end ) The intent is immediately clear - this is a derived value. The logic is only specified once, in one callback. The computed updates itself when a state object you :get() changes value. The callback is the only thing that can change the value - there is no :set() method. A warning about delays in computed callbacks One small caveat of computeds is that you must return the value immediately. If you need to send a request to the server or perform a long-running calculation, you shouldn't use computeds. The reason for this is consistency between variables. When all computeds run immediately (i.e. without yielding), all of your variables will behave consistently: local numCoins = Value ( 50 ) local isEnoughCoins = Computed ( function () return numCoins : get () > 25 end ) local message = Computed ( function () if isEnoughCoins : get () then return numCoins : get () .. \" is enough coins.\" else return numCoins : get () .. \" is NOT enough coins.\" end end ) print ( message : get ()) --> 50 is enough coins. numCoins : set ( 2 ) print ( message : get ()) --> 2 is NOT enough coins. If a delay is introduced, then inconsistencies and nonsense values could quickly appear: local numCoins = Value ( 50 ) local isEnoughCoins = Computed ( function () wait ( 5 ) -- Don't do this! This is just for the example return numCoins : get () > 25 end ) local message = Computed ( function () if isEnoughCoins : get () then return numCoins : get () .. \" is enough coins.\" else return numCoins : get () .. \" is NOT enough coins.\" end end ) print ( message : get ()) --> 50 is enough coins. numCoins : set ( 2 ) print ( message : get ()) --> 2 is enough coins. For this reason, yielding in computed callbacks is disallowed. If you have to introduce a delay, for example when invoking a RemoteFunction, consider using values and observers. local numCoins = Value ( 50 ) local isEnoughCoins = Value ( nil ) local function updateIsEnoughCoins () isEnoughCoins : set ( nil ) -- indicate that we're calculating the value wait ( 5 ) -- this is now ok isEnoughCoins : set ( numCoins : get () > 25 ) end task . spawn ( updateIsEnoughCoins ) Observer ( numCoins ): onChange ( updateIsEnoughCoins ) local message = Computed ( function () if isEnoughCoins : get () == nil then return \"Loading...\" elseif isEnoughCoins : get () then return numCoins : get () .. \" is enough coins.\" else return numCoins : get () .. \" is NOT enough coins.\" end end ) print ( message : get ()) --> 50 is enough coins. numCoins : set ( 2 ) print ( message : get ()) --> Loading... wait ( 5 ) print ( message : get ()) --> 2 is NOT enough coins.","title":"When To Use This"},{"location":"tutorials/fundamentals/observers/","text":"Observers allow you to detect when any state object changes value. You can connect handlers using :onChange() , which returns a function you can call to disconnect it later. local observer = Observer ( health ) local disconnect = observer : onChange ( function () print ( \"The new value is: \" , health : get ()) end ) task . wait ( 5 ) disconnect () Usage \u00b6 To use Observer in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local Observer = Fusion . Observer To create a new observer, call the Observer function with an object to watch: local health = Value ( 100 ) -- This observer will watch `health` for changes: local observer = Observer ( health ) When the watched object changes value, the observer will run all of its handlers. To add a handler, you can use :onChange() : local disconnect = observer : onChange ( function () print ( \"The new value is: \" , health : get ()) end ) When you're done with the handler, it's very important to disconnect it. The :onChange() method returns a function you can call to disconnect your handler: local disconnect = observer : onChange ( function () print ( \"The new value is: \" , health : get ()) end ) -- disconnect the above handler after 5 seconds task . wait ( 5 ) disconnect () Why is disconnecting so important? While an observer has at least one active handler, it will hold the watched object in memory forcibly. This is done to make sure that changes aren't missed. Disconnecting your handlers tells Fusion you don't need to track changes any more, which allows it to clean up the observer and the watched object. What Counts As A Change? \u00b6 You might notice that not all calls to Value:set() will cause your observer to run: Script code Output local thing = Value ( \"Hello\" ) Observer ( thing ): onChange ( function () print ( \"=> Thing changed to\" , thing : get ()) end ) print ( \"Setting thing once...\" ) thing : set ( \"World\" ) print ( \"Setting thing twice...\" ) thing : set ( \"World\" ) print ( \"Setting thing thrice...\" ) thing : set ( \"World\" ) Setting thing once... => Thing changed to World Setting thing twice... Setting thing thrice... When you set the value, if it's the same as the existing value, an update won't be sent out. This means observers won't re-run when you set the value multiple times in a row. In most cases, this leads to improved performance because your code runs less often. However, if you need to override this behaviour, Value:set() accepts a second argument - if you set it to true , an update will be forced: Script code Output local thing = Value ( \"Hello\" ) Observer ( thing ): onChange ( function () print ( \"=> Thing changed to\" , thing : get ()) end ) print ( \"Setting thing once...\" ) thing : set ( \"World\" ) print ( \"Setting thing twice...\" ) thing : set ( \"World\" ) print ( \"Setting thing thrice (update forced)...\" ) thing : set ( \"World\" , true ) Setting thing once... => Thing changed to World Setting thing twice... Setting thing thrice (update forced)... => Thing changed to World","title":"Observers"},{"location":"tutorials/fundamentals/observers/#usage","text":"To use Observer in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local Observer = Fusion . Observer To create a new observer, call the Observer function with an object to watch: local health = Value ( 100 ) -- This observer will watch `health` for changes: local observer = Observer ( health ) When the watched object changes value, the observer will run all of its handlers. To add a handler, you can use :onChange() : local disconnect = observer : onChange ( function () print ( \"The new value is: \" , health : get ()) end ) When you're done with the handler, it's very important to disconnect it. The :onChange() method returns a function you can call to disconnect your handler: local disconnect = observer : onChange ( function () print ( \"The new value is: \" , health : get ()) end ) -- disconnect the above handler after 5 seconds task . wait ( 5 ) disconnect () Why is disconnecting so important? While an observer has at least one active handler, it will hold the watched object in memory forcibly. This is done to make sure that changes aren't missed. Disconnecting your handlers tells Fusion you don't need to track changes any more, which allows it to clean up the observer and the watched object.","title":"Usage"},{"location":"tutorials/fundamentals/observers/#what-counts-as-a-change","text":"You might notice that not all calls to Value:set() will cause your observer to run: Script code Output local thing = Value ( \"Hello\" ) Observer ( thing ): onChange ( function () print ( \"=> Thing changed to\" , thing : get ()) end ) print ( \"Setting thing once...\" ) thing : set ( \"World\" ) print ( \"Setting thing twice...\" ) thing : set ( \"World\" ) print ( \"Setting thing thrice...\" ) thing : set ( \"World\" ) Setting thing once... => Thing changed to World Setting thing twice... Setting thing thrice... When you set the value, if it's the same as the existing value, an update won't be sent out. This means observers won't re-run when you set the value multiple times in a row. In most cases, this leads to improved performance because your code runs less often. However, if you need to override this behaviour, Value:set() accepts a second argument - if you set it to true , an update will be forced: Script code Output local thing = Value ( \"Hello\" ) Observer ( thing ): onChange ( function () print ( \"=> Thing changed to\" , thing : get ()) end ) print ( \"Setting thing once...\" ) thing : set ( \"World\" ) print ( \"Setting thing twice...\" ) thing : set ( \"World\" ) print ( \"Setting thing thrice (update forced)...\" ) thing : set ( \"World\" , true ) Setting thing once... => Thing changed to World Setting thing twice... Setting thing thrice (update forced)... => Thing changed to World","title":"What Counts As A Change?"},{"location":"tutorials/fundamentals/values/","text":"Values are objects which store single values. You can read from them with :get() , and write to them with :set() . local health = Value ( 100 ) print ( health : get ()) --> 100 health : set ( 25 ) print ( health : get ()) --> 25 Usage \u00b6 To use Value in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local Value = Fusion . Value To create a new value, call the Value function: local health = Value () -- this will create and return a new Value object By default, new Value objects store nil . If you want the Value object to start with a different value, you can provide one: local health = Value ( 100 ) -- the Value will initially store a value of 100 You can retrieve the currently stored value at any time with :get() : print ( health : get ()) --> 100 You can also set the stored value at any time with :set() : health : set ( 25 ) print ( health : get ()) --> 25 Why Objects? \u00b6 The Problem \u00b6 Imagine some UI in your head. Think about what it looks like, and think about the different variables it's showing to you. Screenshot: GameUIDatabase (Halo Infinite) Our UIs are usually driven by a few internal variables. When those variables change, we want our UI to reflect those changes. Unfortunately, there's no way to listen for those changes in Lua. When you change those variables, it's normally your responsibility to figure out what needs to update, and to send out those updates. Over time, we've come up with many methods of dealing with this inconvenience. Perhaps the simplest are 'setter functions', like these: local ammo = 100 local function setAmmo ( newAmmo ) ammo = newAmmo -- we need to send out updates to every piece of code using `ammo` here updateHUD () updateGunModel () sendAmmoToServer () end But this is clunky and unreliable; what if there's another piece of code using ammo that we've forgotten to update here? How can you guarantee we've covered everything? Moreover, why is the code setting the ammo even concerned with who uses it? Building Better Variables \u00b6 In an ideal world, anyone using ammo should be able to listen for changes, and get notified when someone sets it to a new value. To make this work, we need to fundamentally extend what variables can do. In particular, we need two additional features: We need to save a list of dependents - other places currently using our variable. This is so we know who to notify when the value changes. We need to run some code when the variable is set to a new value. If we can do that, then we can go through the list and notify everyone. To solve this, Fusion introduces the idea of a 'state object'. These are objects that represent a single value, which you can :get() at any time. They also keep a list of dependents; when the object's value changes, it can notify everyone so they can respond to the change. Value is one such state object. It's specifically designed to act like a variable, so it has an extra :set() method. Using that method, you can change the object's value manually. If you set it to a different value than before, it'll notify anyone using the object. This means we can use Value objects like variables, with the added benefit of being able to listen to changes like we wanted! Sharing Variables \u00b6 There is another benefit to using objects too; you can easily share your objects directly with other code. Every usage of that object will refer to the same underlying value: -- someObject is a `Value` object local function printValue ( someObject ) print ( someObject : get ()) end local health = Value ( 100 ) printValue ( health ) --> 100 local myDogsName = Value ( \"Dan\" ) printValue ( myDogsName ) --> Dan This is something that normal variables can't do by default, and is a benefit exclusive to state objects. In the above code, printValue can operate on any arbitrary variable without knowing what it is, or where it comes from. This is very useful for writing generic, reusable code, and you'll see it used a lot throughout Fusion.","title":"Values"},{"location":"tutorials/fundamentals/values/#usage","text":"To use Value in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local Value = Fusion . Value To create a new value, call the Value function: local health = Value () -- this will create and return a new Value object By default, new Value objects store nil . If you want the Value object to start with a different value, you can provide one: local health = Value ( 100 ) -- the Value will initially store a value of 100 You can retrieve the currently stored value at any time with :get() : print ( health : get ()) --> 100 You can also set the stored value at any time with :set() : health : set ( 25 ) print ( health : get ()) --> 25","title":"Usage"},{"location":"tutorials/fundamentals/values/#why-objects","text":"","title":"Why Objects?"},{"location":"tutorials/fundamentals/values/#the-problem","text":"Imagine some UI in your head. Think about what it looks like, and think about the different variables it's showing to you. Screenshot: GameUIDatabase (Halo Infinite) Our UIs are usually driven by a few internal variables. When those variables change, we want our UI to reflect those changes. Unfortunately, there's no way to listen for those changes in Lua. When you change those variables, it's normally your responsibility to figure out what needs to update, and to send out those updates. Over time, we've come up with many methods of dealing with this inconvenience. Perhaps the simplest are 'setter functions', like these: local ammo = 100 local function setAmmo ( newAmmo ) ammo = newAmmo -- we need to send out updates to every piece of code using `ammo` here updateHUD () updateGunModel () sendAmmoToServer () end But this is clunky and unreliable; what if there's another piece of code using ammo that we've forgotten to update here? How can you guarantee we've covered everything? Moreover, why is the code setting the ammo even concerned with who uses it?","title":"The Problem"},{"location":"tutorials/fundamentals/values/#building-better-variables","text":"In an ideal world, anyone using ammo should be able to listen for changes, and get notified when someone sets it to a new value. To make this work, we need to fundamentally extend what variables can do. In particular, we need two additional features: We need to save a list of dependents - other places currently using our variable. This is so we know who to notify when the value changes. We need to run some code when the variable is set to a new value. If we can do that, then we can go through the list and notify everyone. To solve this, Fusion introduces the idea of a 'state object'. These are objects that represent a single value, which you can :get() at any time. They also keep a list of dependents; when the object's value changes, it can notify everyone so they can respond to the change. Value is one such state object. It's specifically designed to act like a variable, so it has an extra :set() method. Using that method, you can change the object's value manually. If you set it to a different value than before, it'll notify anyone using the object. This means we can use Value objects like variables, with the added benefit of being able to listen to changes like we wanted!","title":"Building Better Variables"},{"location":"tutorials/fundamentals/values/#sharing-variables","text":"There is another benefit to using objects too; you can easily share your objects directly with other code. Every usage of that object will refer to the same underlying value: -- someObject is a `Value` object local function printValue ( someObject ) print ( someObject : get ()) end local health = Value ( 100 ) printValue ( health ) --> 100 local myDogsName = Value ( \"Dan\" ) printValue ( myDogsName ) --> Dan This is something that normal variables can't do by default, and is a benefit exclusive to state objects. In the above code, printValue can operate on any arbitrary variable without knowing what it is, or where it comes from. This is very useful for writing generic, reusable code, and you'll see it used a lot throughout Fusion.","title":"Sharing Variables"},{"location":"tutorials/instances/change-events/","text":"OnChange is a function that returns keys to use when hydrating or creating an instance. Those keys let you connect functions to property changed events on the instance. local input = New \"TextBox\" { [ OnChange \"Text\" ] = function ( newText ) print ( \"You typed:\" , newText ) end } Usage \u00b6 To use OnChange in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local OnChange = Fusion . OnChange When you call OnChange with a property name, it will return a special key: local key = OnEvent ( \"Activated\" ) When used in a property table, you can pass in a handler and it will be run when that property changes. The new value of the property is passed in: local input = New \"TextBox\" { [ OnChange ( \"Text\" )] = function ( newText ) print ( \"You typed:\" , newText ) end } If you're using quotes '' \"\" for the event name, the extra parentheses () are optional: local input = New \"TextBox\" { [ OnChange \"Text\" ] = function ( newText ) print ( \"You typed:\" , newText ) end } A warning about using OnChange with state objects When passing a state object as a property, changes will only affect the property on the next frame: local text = Value ( \"Hello\" ) local message = New \"Message\" { Text = text } print ( message . Text ) --> Hello text : set ( \"World\" ) print ( message . Text ) --> Hello task . wait () -- wait for next frame print ( message . Text ) --> World This means OnChange for that property will run your handlers one frame after the state object is changed. This could introduce off-by-one-frame errors. For this case, prefer to use an observer on the state object directly for zero latency. Differences from Roblox API \u00b6 Normally in the Roblox API, when using :GetPropertyChangedSignal() on an instance, the handler callback will not receive any arguments. It's worth noting that OnChange is not identical in that respect. To make working with change events easier, OnChange will pass the new value of the property to the handler callback.","title":"Change Events"},{"location":"tutorials/instances/change-events/#usage","text":"To use OnChange in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local OnChange = Fusion . OnChange When you call OnChange with a property name, it will return a special key: local key = OnEvent ( \"Activated\" ) When used in a property table, you can pass in a handler and it will be run when that property changes. The new value of the property is passed in: local input = New \"TextBox\" { [ OnChange ( \"Text\" )] = function ( newText ) print ( \"You typed:\" , newText ) end } If you're using quotes '' \"\" for the event name, the extra parentheses () are optional: local input = New \"TextBox\" { [ OnChange \"Text\" ] = function ( newText ) print ( \"You typed:\" , newText ) end } A warning about using OnChange with state objects When passing a state object as a property, changes will only affect the property on the next frame: local text = Value ( \"Hello\" ) local message = New \"Message\" { Text = text } print ( message . Text ) --> Hello text : set ( \"World\" ) print ( message . Text ) --> Hello task . wait () -- wait for next frame print ( message . Text ) --> World This means OnChange for that property will run your handlers one frame after the state object is changed. This could introduce off-by-one-frame errors. For this case, prefer to use an observer on the state object directly for zero latency.","title":"Usage"},{"location":"tutorials/instances/change-events/#differences-from-roblox-api","text":"Normally in the Roblox API, when using :GetPropertyChangedSignal() on an instance, the handler callback will not receive any arguments. It's worth noting that OnChange is not identical in that respect. To make working with change events easier, OnChange will pass the new value of the property to the handler callback.","title":"Differences from Roblox API"},{"location":"tutorials/instances/cleanup/","text":"The [Cleanup] key allows you to add cleanup code to an instance you're hydrating or creating. You can also pass in instances or event connections to destroy. local connection = RunService . Heartbeat : Connect ( function () print ( \"Blah blah...\" ) end ) local part = New \"Part\" { [ Cleanup ] = connection } local box = New \"SelectionBox\" { Parent = PlayerGui } local part = New \"Part\" { [ Cleanup ] = box } local part = New \"Part\" { [ Cleanup ] = { function () print ( \"Oh no, I got destroyed. Ouch :(\" ) end , connection , box } } Usage \u00b6 To use Cleanup in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local Cleanup = Fusion . Cleanup When using New or Hydrate , you can use [Cleanup] as a key in the property table. Any function you pass in will be run when the instance is destroyed: local folder = New \"Folder\" { [ Cleanup ] = function () print ( \"This folder was destroyed\" ) end } Arrays are supported - their contents will be cleaned up in order: local folder = New \"Folder\" { [ Cleanup ] = { function () print ( \"This will run first\" ) end , function () print ( \"This will run next\" ) end , function () print ( \"This will run last\" ) end } } You may also nest arrays up to any depth - sub-arrays are also run in order: local folder = New \"Folder\" { [ Cleanup ] = { function () print ( \"This will run first\" ) end , { function () print ( \"This will run next\" ) end , function () print ( \"This will run second-to-last\" ) end , }, function () print ( \"This will run last\" ) end } } For convenience, Cleanup allows you to pass some types of value in directly. Passing in an instance will destroy it: local box = New \"SelectionBox\" { Parent = PlayerGui } local part = New \"Part\" { -- `box` will be destroyed when the part is destroyed [ Cleanup ] = box } Passing in an event connection will disconnect it: local connection = RunService . Heartbeat : Connect ( function () print ( \"Blah blah...\" ) end ) local part = New \"Part\" { -- `connection` will be disconnected when the part is destroyed [ Cleanup ] = connection } Finally, passing in anything with a :destroy() or :Destroy() method will have that method called: -- you might receive an object like this from a third party library local object = {} function object : destroy () print ( \"I was destroyed!\" ) end local part = New \"Part\" { -- `object:destroy()` will be called when the part is destroyed [ Cleanup ] = object } Any other kind of value will do nothing by default. Don't Use Destroyed \u00b6 While Roblox does provide it's own Destroyed event, it should not be relied upon for cleaning up correctly in all cases. It only fires when the Destroy method is called, meaning other kinds of destruction are ignored. For example, notice only one of these parts runs their cleanup code: Script code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 local part1 = New \"Part\" { [ OnEvent \"Destroyed\" ] = function () print ( \"=> Part 1 cleaned up\" ) end } local part2 = New \"Part\" { [ OnEvent \"Destroyed\" ] = function () print ( \"=> Part 2 cleaned up\" ) end } print ( \"Destroying part 1...\" ) part1 : Destroy () print ( \"Setting part 2 to nil...\" ) part2 = nil Destroying part 1... => Part 1 cleaned up Setting part 2 to nil... Meanwhile, Fusion's [Cleanup] will work regardless of how your instances were destroyed, meaning you can avoid serious memory leaks: Script code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 local part1 = New \"Part\" { [ Cleanup ] = function () print ( \"=> Part 1 cleaned up\" ) end } local part2 = New \"Part\" { [ Cleanup ] = function () print ( \"=> Part 2 cleaned up\" ) end } print ( \"Destroying part 1...\" ) part1 : Destroy () print ( \"Setting part 2 to nil...\" ) part2 = nil Destroying part 1... => Part 1 cleaned up Setting part 2 to nil... => Part 2 cleaned up","title":"Cleanup"},{"location":"tutorials/instances/cleanup/#usage","text":"To use Cleanup in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local Cleanup = Fusion . Cleanup When using New or Hydrate , you can use [Cleanup] as a key in the property table. Any function you pass in will be run when the instance is destroyed: local folder = New \"Folder\" { [ Cleanup ] = function () print ( \"This folder was destroyed\" ) end } Arrays are supported - their contents will be cleaned up in order: local folder = New \"Folder\" { [ Cleanup ] = { function () print ( \"This will run first\" ) end , function () print ( \"This will run next\" ) end , function () print ( \"This will run last\" ) end } } You may also nest arrays up to any depth - sub-arrays are also run in order: local folder = New \"Folder\" { [ Cleanup ] = { function () print ( \"This will run first\" ) end , { function () print ( \"This will run next\" ) end , function () print ( \"This will run second-to-last\" ) end , }, function () print ( \"This will run last\" ) end } } For convenience, Cleanup allows you to pass some types of value in directly. Passing in an instance will destroy it: local box = New \"SelectionBox\" { Parent = PlayerGui } local part = New \"Part\" { -- `box` will be destroyed when the part is destroyed [ Cleanup ] = box } Passing in an event connection will disconnect it: local connection = RunService . Heartbeat : Connect ( function () print ( \"Blah blah...\" ) end ) local part = New \"Part\" { -- `connection` will be disconnected when the part is destroyed [ Cleanup ] = connection } Finally, passing in anything with a :destroy() or :Destroy() method will have that method called: -- you might receive an object like this from a third party library local object = {} function object : destroy () print ( \"I was destroyed!\" ) end local part = New \"Part\" { -- `object:destroy()` will be called when the part is destroyed [ Cleanup ] = object } Any other kind of value will do nothing by default.","title":"Usage"},{"location":"tutorials/instances/cleanup/#dont-use-destroyed","text":"While Roblox does provide it's own Destroyed event, it should not be relied upon for cleaning up correctly in all cases. It only fires when the Destroy method is called, meaning other kinds of destruction are ignored. For example, notice only one of these parts runs their cleanup code: Script code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 local part1 = New \"Part\" { [ OnEvent \"Destroyed\" ] = function () print ( \"=> Part 1 cleaned up\" ) end } local part2 = New \"Part\" { [ OnEvent \"Destroyed\" ] = function () print ( \"=> Part 2 cleaned up\" ) end } print ( \"Destroying part 1...\" ) part1 : Destroy () print ( \"Setting part 2 to nil...\" ) part2 = nil Destroying part 1... => Part 1 cleaned up Setting part 2 to nil... Meanwhile, Fusion's [Cleanup] will work regardless of how your instances were destroyed, meaning you can avoid serious memory leaks: Script code Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 local part1 = New \"Part\" { [ Cleanup ] = function () print ( \"=> Part 1 cleaned up\" ) end } local part2 = New \"Part\" { [ Cleanup ] = function () print ( \"=> Part 2 cleaned up\" ) end } print ( \"Destroying part 1...\" ) part1 : Destroy () print ( \"Setting part 2 to nil...\" ) part2 = nil Destroying part 1... => Part 1 cleaned up Setting part 2 to nil... => Part 2 cleaned up","title":"Don't Use Destroyed"},{"location":"tutorials/instances/events/","text":"OnEvent is a function that returns keys to use when hydrating or creating an instance. Those keys let you connect functions to events on the instance. local button = New \"TextButton\" { [ OnEvent \"Activated\" ] = function ( _ , numClicks ) print ( \"The button was pressed\" , numClicks , \"time(s)!\" ) end } Usage \u00b6 To use OnEvent in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local OnEvent = Fusion . OnEvent When you call OnEvent with an event name, it will return a special key: local key = OnEvent ( \"Activated\" ) When that key is used in a property table, you can pass in a handler and it will be connected to the event for you: local button = New \"TextButton\" { [ OnEvent ( \"Activated\" )] = function ( _ , numClicks ) print ( \"The button was pressed\" , numClicks , \"time(s)!\" ) end } If you're using quotes '' \"\" for the event name, the extra parentheses () are optional: local button = New \"TextButton\" { [ OnEvent \"Activated\" ] = function ( _ , numClicks ) print ( \"The button was pressed\" , numClicks , \"time(s)!\" ) end }","title":"Events"},{"location":"tutorials/instances/events/#usage","text":"To use OnEvent in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local OnEvent = Fusion . OnEvent When you call OnEvent with an event name, it will return a special key: local key = OnEvent ( \"Activated\" ) When that key is used in a property table, you can pass in a handler and it will be connected to the event for you: local button = New \"TextButton\" { [ OnEvent ( \"Activated\" )] = function ( _ , numClicks ) print ( \"The button was pressed\" , numClicks , \"time(s)!\" ) end } If you're using quotes '' \"\" for the event name, the extra parentheses () are optional: local button = New \"TextButton\" { [ OnEvent \"Activated\" ] = function ( _ , numClicks ) print ( \"The button was pressed\" , numClicks , \"time(s)!\" ) end }","title":"Usage"},{"location":"tutorials/instances/hydration/","text":"The process of connecting your scripts to a pre-made UI template is known as hydration . This is where logic in your scripts translate into UI effects, for example setting a message inside a TextLabel, moving menus around, or showing and hiding buttons. Screenshot: GameUIDatabase (Halo Infinite) Fusion provides a Hydrate function for hydrating an instance using a table of properties. If you pass in Fusion objects, changes will be applied on the next frame: local showUI = Value ( false ) local ui = Hydrate ( StarterGui . Template : Clone ()) { Name = \"MainGui\" , Enabled = showUI } print ( ui . Name ) --> MainGui print ( ui . Enabled ) --> false showUI : set ( true ) task . wait () -- important: changes are applied on the next frame! print ( ui . Enabled ) --> true Usage \u00b6 To use Hydrate in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local Hydrate = Fusion . Hydrate The Hydrate function is called in two parts. First, call the function with the instance you want to hydrate, then pass in the property table: local instance = workspace . Part Hydrate ( instance )({ Color = Color3 . new ( 1 , 0 , 0 ) }) If you're using curly braces {} to pass your properties in, the extra parentheses () are optional: local instance = workspace . Part -- This only works when you're using curly braces {}! Hydrate ( instance ) { Color = Color3 . new ( 1 , 0 , 0 ) } Hydrate returns the instance you give it, so you can use it in declarations: local instance = Hydrate ( workspace . Part ) { Color = Color3 . new ( 1 , 0 , 0 ) } If you pass in constant values for properties, they'll be applied to the instance directly. However, if you pass in a Fusion object (like Value ), then changes will be applied on the next frame: local message = Value ( \"Loading...\" ) Hydrate ( PlayerGui . LoadingText ) { Text = message } print ( PlayerGui . Message . Text ) --> Loading... message : set ( \"All done!\" ) task . wait () -- important: changes are applied on the next frame! print ( PlayerGui . Message . Text ) --> All done!","title":"Hydration"},{"location":"tutorials/instances/hydration/#usage","text":"To use Hydrate in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local Hydrate = Fusion . Hydrate The Hydrate function is called in two parts. First, call the function with the instance you want to hydrate, then pass in the property table: local instance = workspace . Part Hydrate ( instance )({ Color = Color3 . new ( 1 , 0 , 0 ) }) If you're using curly braces {} to pass your properties in, the extra parentheses () are optional: local instance = workspace . Part -- This only works when you're using curly braces {}! Hydrate ( instance ) { Color = Color3 . new ( 1 , 0 , 0 ) } Hydrate returns the instance you give it, so you can use it in declarations: local instance = Hydrate ( workspace . Part ) { Color = Color3 . new ( 1 , 0 , 0 ) } If you pass in constant values for properties, they'll be applied to the instance directly. However, if you pass in a Fusion object (like Value ), then changes will be applied on the next frame: local message = Value ( \"Loading...\" ) Hydrate ( PlayerGui . LoadingText ) { Text = message } print ( PlayerGui . Message . Text ) --> Loading... message : set ( \"All done!\" ) task . wait () -- important: changes are applied on the next frame! print ( PlayerGui . Message . Text ) --> All done!","title":"Usage"},{"location":"tutorials/instances/new-instances/","text":"Fusion provides a New function when you're hydrating newly-made instances. It creates a new instance, applies some default properties, then hydrates it with a property table. local message = Value ( \"Hello there!\" ) local ui = New \"TextLabel\" { Name = \"Greeting\" , Parent = PlayerGui . ScreenGui , Text = message } print ( ui . Name ) --> Greeting print ( ui . Text ) --> Hello there! message : set ( \"Goodbye friend!\" ) task . wait () -- important: changes are applied on the next frame! print ( ui . Text ) --> Goodbye friend! Usage \u00b6 To use New in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New The New function is called in two parts. First, call the function with the type of instance, then pass in the property table: local instance = New ( \"Part\" )({ Parent = workspace , Color = Color3 . new ( 1 , 0 , 0 ) }) If you're using curly braces {} for your properties, and quotes '' \"\" for your class type, the extra parentheses () are optional: -- This only works when you're using curly braces {} and quotes '' \"\"! local instance = New \"Part\" { Parent = workspace , Color = Color3 . new ( 1 , 0 , 0 ) } By design, New works just like Hydrate - it will apply properties the same way. See the Hydrate tutorial to learn more. Default Properties \u00b6 When you create an instance using Instance.new() , Roblox will give it some default properties. However, these tend to be outdated and aren't useful for most people, leading to repetitive boilerplate needed to disable features that nobody wants to use. The New function will apply some of it's own default properties to fix this. For example, by default borders on UI are disabled, automatic colouring is turned off and default content is removed. For a complete list, take a look at Fusion's default properties file.","title":"New Instances"},{"location":"tutorials/instances/new-instances/#usage","text":"To use New in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local New = Fusion . New The New function is called in two parts. First, call the function with the type of instance, then pass in the property table: local instance = New ( \"Part\" )({ Parent = workspace , Color = Color3 . new ( 1 , 0 , 0 ) }) If you're using curly braces {} for your properties, and quotes '' \"\" for your class type, the extra parentheses () are optional: -- This only works when you're using curly braces {} and quotes '' \"\"! local instance = New \"Part\" { Parent = workspace , Color = Color3 . new ( 1 , 0 , 0 ) } By design, New works just like Hydrate - it will apply properties the same way. See the Hydrate tutorial to learn more.","title":"Usage"},{"location":"tutorials/instances/new-instances/#default-properties","text":"When you create an instance using Instance.new() , Roblox will give it some default properties. However, these tend to be outdated and aren't useful for most people, leading to repetitive boilerplate needed to disable features that nobody wants to use. The New function will apply some of it's own default properties to fix this. For example, by default borders on UI are disabled, automatic colouring is turned off and default content is removed. For a complete list, take a look at Fusion's default properties file.","title":"Default Properties"},{"location":"tutorials/instances/outputs/","text":"Out is a function that returns keys to use when hydrating or creating an instance. Those keys let you output a property's value to a Value object. local name = Value () local thing = New \"Part\" { [ Out \"Name\" ] = name } print ( name : get ()) --> Part thing . Name = \"Jimmy\" print ( name : get ()) --> Jimmy Usage \u00b6 To use Out in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local Out = Fusion . Out When you call Out with a property name, it will return a special key: local key = Out ( \"Activated\" ) When used in a property table, you can pass in a Value object. It will be set to the value of the property, and when the property changes, it will be set to the new value: local name = Value () local thing = New \"Part\" { [ Out ( \"Name\" )] = name } print ( name : get ()) --> Part thing . Name = \"Jimmy\" print ( name : get ()) --> Jimmy If you're using quotes '' \"\" for the event name, the extra parentheses () are optional: local thing = New \"Part\" { [ Out \"Name\" ] = name } Two-Way Binding \u00b6 By default, Out only outputs changes to the property. If you set the value to something else, the property remains the same: local name = Value () local thing = New \"Part\" { [ Out \"Name\" ] = name -- When `thing.Name` changes, set `name` } print ( thing . Name , name : get ()) --> Part Part name : set ( \"NewName\" ) task . wait () print ( thing . Name , name : get ()) --> Part NewName If you want the value to both change and be changed by the property, you need to explicitly say so: local name = Value () local thing = New \"Part\" { Name = name -- When `name` changes, set `thing.Name` [ Out \"Name\" ] = name -- When `thing.Name` changes, set `name` } print ( thing . Name , name : get ()) --> Part Part name : set ( \"NewName\" ) task . wait () print ( thing . Name , name : get ()) --> NewName NewName This is known as two-way binding. Most of the time you won't need it, but it can come in handy when working with some kinds of UI - for example, a text box that users can write into, but which can also be modified by your scripts.","title":"Outputs"},{"location":"tutorials/instances/outputs/#usage","text":"To use Out in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local Out = Fusion . Out When you call Out with a property name, it will return a special key: local key = Out ( \"Activated\" ) When used in a property table, you can pass in a Value object. It will be set to the value of the property, and when the property changes, it will be set to the new value: local name = Value () local thing = New \"Part\" { [ Out ( \"Name\" )] = name } print ( name : get ()) --> Part thing . Name = \"Jimmy\" print ( name : get ()) --> Jimmy If you're using quotes '' \"\" for the event name, the extra parentheses () are optional: local thing = New \"Part\" { [ Out \"Name\" ] = name }","title":"Usage"},{"location":"tutorials/instances/outputs/#two-way-binding","text":"By default, Out only outputs changes to the property. If you set the value to something else, the property remains the same: local name = Value () local thing = New \"Part\" { [ Out \"Name\" ] = name -- When `thing.Name` changes, set `name` } print ( thing . Name , name : get ()) --> Part Part name : set ( \"NewName\" ) task . wait () print ( thing . Name , name : get ()) --> Part NewName If you want the value to both change and be changed by the property, you need to explicitly say so: local name = Value () local thing = New \"Part\" { Name = name -- When `name` changes, set `thing.Name` [ Out \"Name\" ] = name -- When `thing.Name` changes, set `name` } print ( thing . Name , name : get ()) --> Part Part name : set ( \"NewName\" ) task . wait () print ( thing . Name , name : get ()) --> NewName NewName This is known as two-way binding. Most of the time you won't need it, but it can come in handy when working with some kinds of UI - for example, a text box that users can write into, but which can also be modified by your scripts.","title":"Two-Way Binding"},{"location":"tutorials/instances/parenting/","text":"The [Children] key allows you to add children when hydrating or creating an instance. It accepts instances, arrays of children and state objects containing children. local folder = New \"Folder\" { [ Children ] = { New \"Part\" { Name = \"Gregory\" , Color = Color3 . new ( 1 , 0 , 0 ) }, New \"Part\" { Name = \"Sammy\" , Material = \"Glass\" } } } Usage \u00b6 To use Children in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local Children = Fusion . Children When using New or Hydrate , you can use [Children] as a key in the property table. Any instance you pass in will be parented: local folder = New \"Folder\" { -- The part will be moved inside of the folder [ Children ] = workspace . Part } Since New and Hydrate both return their instances, you can nest them: -- Makes a Folder, containing a part called Gregory local folder = New \"Folder\" { [ Children ] = New \"Part\" { Name = \"Gregory\" , Color = Color3 . new ( 1 , 0 , 0 ) } } If you need to parent multiple children, arrays of children are accepted: -- Makes a Folder, containing parts called Gregory and Sammy local folder = New \"Folder\" { [ Children ] = { New \"Part\" { Name = \"Gregory\" , Color = Color3 . new ( 1 , 0 , 0 ) }, New \"Part\" { Name = \"Sammy\" , Material = \"Glass\" } } } Arrays can be nested to any depth; all children will still be parented: local folder = New \"Folder\" { [ Children ] = { { { { New \"Part\" { Name = \"Gregory\" , Color = Color3 . new ( 1 , 0 , 0 ) } } } } } } Similarly, state objects containing children (or nil ) are also allowed: local value = Value () local folder = New \"Folder\" { [ Children ] = value } value : set ( New \"Part\" { Name = \"Clyde\" , Transparency = 0.5 } ) You may use any combination of these to parent whichever children you need: local modelChildren = workspace . Model : GetChildren () local includeModel = Value ( true ) local folder = New \"Folder\" { -- array of children [ Children ] = { -- single instance New \"Part\" { Name = \"Gregory\" , Color = Color3 . new ( 1 , 0 , 0 ) }, -- state object containing children (or nil) Computed ( function () return if includeModel : get () then modelChildren : GetChildren () -- array of children else nil end ) } }","title":"Parenting"},{"location":"tutorials/instances/parenting/#usage","text":"To use Children in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local Children = Fusion . Children When using New or Hydrate , you can use [Children] as a key in the property table. Any instance you pass in will be parented: local folder = New \"Folder\" { -- The part will be moved inside of the folder [ Children ] = workspace . Part } Since New and Hydrate both return their instances, you can nest them: -- Makes a Folder, containing a part called Gregory local folder = New \"Folder\" { [ Children ] = New \"Part\" { Name = \"Gregory\" , Color = Color3 . new ( 1 , 0 , 0 ) } } If you need to parent multiple children, arrays of children are accepted: -- Makes a Folder, containing parts called Gregory and Sammy local folder = New \"Folder\" { [ Children ] = { New \"Part\" { Name = \"Gregory\" , Color = Color3 . new ( 1 , 0 , 0 ) }, New \"Part\" { Name = \"Sammy\" , Material = \"Glass\" } } } Arrays can be nested to any depth; all children will still be parented: local folder = New \"Folder\" { [ Children ] = { { { { New \"Part\" { Name = \"Gregory\" , Color = Color3 . new ( 1 , 0 , 0 ) } } } } } } Similarly, state objects containing children (or nil ) are also allowed: local value = Value () local folder = New \"Folder\" { [ Children ] = value } value : set ( New \"Part\" { Name = \"Clyde\" , Transparency = 0.5 } ) You may use any combination of these to parent whichever children you need: local modelChildren = workspace . Model : GetChildren () local includeModel = Value ( true ) local folder = New \"Folder\" { -- array of children [ Children ] = { -- single instance New \"Part\" { Name = \"Gregory\" , Color = Color3 . new ( 1 , 0 , 0 ) }, -- state object containing children (or nil) Computed ( function () return if includeModel : get () then modelChildren : GetChildren () -- array of children else nil end ) } }","title":"Usage"},{"location":"tutorials/instances/references/","text":"The [Ref] key allows you to save a reference to an instance you're hydrating or creating. local myRef = Value () local thing = New \"Part\" { [ Ref ] = myRef } print ( myRef : get ()) --> Part print ( myRef : get () == thing ) --> true Usage \u00b6 To use Ref in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local Ref = Fusion . Ref When using New or Hydrate , you can use [Ref] as a key in the property table. It expects a value object to be passed in, and it will save a reference to the instance in that object: local myRef = Value () New \"Part\" { [ Ref ] = myRef } print ( myRef : get ()) --> Part When the instance is cleaned up, the value object is set to nil to avoid memory leaks: local myPart = Value () New \"Part\" { [ Ref ] = myPart } print ( myPart : get ()) --> Part myPart : get (): Destroy () print ( myPart : get ()) --> nil When To Use This \u00b6 You may have noticed that New and Hydrate already return their instances. You might wonder why there's two ways to get the same instance reference: local fromRef = Value () local returned = New \"Part\" { [ Ref ] = fromRef } print ( returned ) --> Part print ( fromRef : get ()) --> Part print ( returned == fromRef : get ()) --> true There are two main use cases. Firstly, when you're using [Children] to nest instances inside each other, it's hard to access the instance reference: local folders = New \"Folder\" { [ Children ] = New \"Folder\" { -- the instance reference gets passed straight into [Children] -- so... how do we save this somewhere else? [ Children ] = New \"Part\" {} } } One solution is to extract the New call out to a separate variable. This is the simplest solution, but because the part is separated from the folders, it's harder to see they're related at a glance: -- build the part elsewhere, so we can save it to a variable local myPart = New \"Part\" {} local folders = New \"Folder\" { [ Children ] = New \"Folder\" { -- use the saved reference [ Children ] = myPart } } Ref allows you to save the reference without moving the New call: -- use a value object instead of a plain variable, so we can pass it to `Ref` local myPart = Value () local folders = New \"Folder\" { [ Children ] = New \"Folder\" { [ Children ] = New \"Part\" { -- save a reference into our value object [ Ref ] = myPart } } } The second use case arises when one instance needs to refer to another. Since Ref saves to a value object, you can pass the object directly into another New or Hydrate call: local myPart = Value () New \"SelectionBox\" { -- the selection box should adorn to the part Adornee = myPart } New \"Part\" { -- saving a reference to `myPart`, which will change the Adornee prop above [ Ref ] = myPart } These aren't the only use cases for Ref , but they're the most common patterns which are worth covering.","title":"References"},{"location":"tutorials/instances/references/#usage","text":"To use Ref in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local Ref = Fusion . Ref When using New or Hydrate , you can use [Ref] as a key in the property table. It expects a value object to be passed in, and it will save a reference to the instance in that object: local myRef = Value () New \"Part\" { [ Ref ] = myRef } print ( myRef : get ()) --> Part When the instance is cleaned up, the value object is set to nil to avoid memory leaks: local myPart = Value () New \"Part\" { [ Ref ] = myPart } print ( myPart : get ()) --> Part myPart : get (): Destroy () print ( myPart : get ()) --> nil","title":"Usage"},{"location":"tutorials/instances/references/#when-to-use-this","text":"You may have noticed that New and Hydrate already return their instances. You might wonder why there's two ways to get the same instance reference: local fromRef = Value () local returned = New \"Part\" { [ Ref ] = fromRef } print ( returned ) --> Part print ( fromRef : get ()) --> Part print ( returned == fromRef : get ()) --> true There are two main use cases. Firstly, when you're using [Children] to nest instances inside each other, it's hard to access the instance reference: local folders = New \"Folder\" { [ Children ] = New \"Folder\" { -- the instance reference gets passed straight into [Children] -- so... how do we save this somewhere else? [ Children ] = New \"Part\" {} } } One solution is to extract the New call out to a separate variable. This is the simplest solution, but because the part is separated from the folders, it's harder to see they're related at a glance: -- build the part elsewhere, so we can save it to a variable local myPart = New \"Part\" {} local folders = New \"Folder\" { [ Children ] = New \"Folder\" { -- use the saved reference [ Children ] = myPart } } Ref allows you to save the reference without moving the New call: -- use a value object instead of a plain variable, so we can pass it to `Ref` local myPart = Value () local folders = New \"Folder\" { [ Children ] = New \"Folder\" { [ Children ] = New \"Part\" { -- save a reference into our value object [ Ref ] = myPart } } } The second use case arises when one instance needs to refer to another. Since Ref saves to a value object, you can pass the object directly into another New or Hydrate call: local myPart = Value () New \"SelectionBox\" { -- the selection box should adorn to the part Adornee = myPart } New \"Part\" { -- saving a reference to `myPart`, which will change the Adornee prop above [ Ref ] = myPart } These aren't the only use cases for Ref , but they're the most common patterns which are worth covering.","title":"When To Use This"},{"location":"tutorials/lists-and-tables/forkeys/","text":"ForKeys is a state object that creates a new table by processing keys from another table. The input table can be a state object, and the output keys can use state objects. local data = { Red = \"foo\" , Blue = \"bar\" } local prefix = Value ( \"Key_\" ) local renamed = ForKeys ( data , function ( key ) return prefix : get () .. key end ) print ( renamed : get ()) --> {Key_Red = \"foo\", Key_Blue = \"bar\"} prefix : set ( \"colour\" ) print ( renamed : get ()) --> {colourRed = \"foo\", colourBlue = \"bar\"} Usage \u00b6 To use ForKeys in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local ForKeys = Fusion . ForKeys Basic Usage \u00b6 To create a new ForKeys object, call the constructor with an input table and a processor function: local data = { red = \"foo\" , blue = \"bar\" } local renamed = ForKeys ( data , function ( key ) return string.upper ( key ) end ) This will generate a new table, where each key is replaced using the processor function. You can get the table using the :get() method: local data = { red = \"foo\" , blue = \"bar\" } local renamed = ForKeys ( data , function ( key ) return string.upper ( key ) end ) print ( renamed : get ()) --> {RED = \"foo\", BLUE = \"bar\"} State Objects \u00b6 The input table can be provided as a state object instead, and the output table will update as the input table is changed: local playerSet = Value ({}) local userIdSet = ForKeys ( playerSet , function ( player ) return player . UserId end ) playerSet : set ({ [ Players . Elttob ] = true }) print ( userIdSet : get ()) --> {[1670764] = true} playerSet : set ({ [ Players . boatbomber ] = true , [ Players . EgoMoose ] = true }) print ( userIdSet : get ()) --> {[33655127] = true, [2155311] = true} Additionally, you can use state objects in your calculations, just like a computed: local playerSet = { [ Players . boatbomber ] = true , [ Players . EgoMoose ] = true } local prefix = Value ( \"User_\" ) local userIdSet = ForKeys ( playerSet , function ( player ) return prefix .. player . UserId end ) print ( userIdSet : get ()) --> {User_33655127 = true, User_2155311 = true} prefix : set ( \"player\" ) print ( userIdSet : get ()) --> {player33655127 = true, player2155311 = true} Cleanup Behaviour \u00b6 By default, ForKeys will clean up any returned keys that get removed, using the same rules as Cleanup . See the cleanup rules here. local eventSet = Value ({ [ RunService . RenderStepped ] = true , [ RunService . Heartbeat ] = true }) local connectionSet = ForKeys ( eventSet , function ( event ) -- make a new connection for each event return event : Connect ( function (...) print ( event , \"fired with arguments:\" , ...) end ) end ) -- remove Heartbeat from the event set -- this will :Disconnect() the Heartbeat connection automatically eventSet : set ({ [ RunService . RenderStepped ] = true }) If you want to run your own code when values are removed instead, you can pass in a second 'destructor' function: local eventSet = Value ({ [ RunService . RenderStepped ] = true , [ RunService . Heartbeat ] = true }) local connectionSet = ForKeys ( eventSet , -- processor function ( event ) local eventName = tostring ( event ) local connection = event : Connect ( function (...) print ( eventName , \"fired with arguments:\" , ...) end ) return connection end , -- destructor function ( connection ) print ( \"Disconnecting the event!\" ) connection : Disconnect () -- don't forget we're overriding the default cleanup end ) -- remove Heartbeat from the event set -- this will run our destructor with the Heartbeat connection eventSet : set ({ [ RunService . RenderStepped ] = true }) --> Disconnecting the event! When using a custom destructor, you can send one extra return value to your destructor without including it in the output table: local eventSet = Value ({ [ RunService . RenderStepped ] = true , [ RunService . Heartbeat ] = true }) local connectionSet = ForKeys ( eventSet , -- processor function ( event ) local eventName = tostring ( event ) local connection = event : Connect ( function (...) print ( eventName , \"fired with arguments:\" , ...) end ) return connection , eventName end , -- destructor function ( connection , eventName ) print ( \"Disconnecting \" .. eventName .. \"!\" ) connection : Disconnect () end ) eventSet : set ({ [ RunService . RenderStepped ] = true }) --> Disconnecting Signal Heartbeat! Optimisations \u00b6 Optional You don't have to memorise these optimisations to use ForKeys , but it can be helpful if you have a performance problem. Rather than creating a new output table from scratch every time the input table is changed, ForKeys will try and reuse as much as possible to improve performance. For example, let's say we're converting an array to a dictionary: local array = Value ({ \"Fusion\" , \"Knit\" , \"Matter\" }) local dict = ForKeys ( array , function ( index ) return \"Value\" .. index end ) print ( dict : get ()) --> {Value1 = \"Fusion\", Value2 = \"Knit\", Value3 = \"Matter\"} Because ForKeys only operates on the keys, changing the values in the array doesn't affect the keys. Keys are only added or removed as needed: local array = Value ({ \"Fusion\" , \"Knit\" , \"Matter\" }) local dict = ForKeys ( array , function ( index ) return \"Value\" .. index end ) print ( dict : get ()) --> {Value1 = \"Fusion\", Value2 = \"Knit\", Value3 = \"Matter\"} array : set ({ \"Roact\" , \"Rodux\" }) print ( dict : get ()) --> {Value1 = \"Roact\", Value2 = \"Rodux\"} ForKeys takes advantage of this - when a value changes, it's copied into the output table without recalculating the key. Keys are only calculated when a value is assigned to a new key.","title":"ForKeys"},{"location":"tutorials/lists-and-tables/forkeys/#usage","text":"To use ForKeys in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local ForKeys = Fusion . ForKeys","title":"Usage"},{"location":"tutorials/lists-and-tables/forkeys/#basic-usage","text":"To create a new ForKeys object, call the constructor with an input table and a processor function: local data = { red = \"foo\" , blue = \"bar\" } local renamed = ForKeys ( data , function ( key ) return string.upper ( key ) end ) This will generate a new table, where each key is replaced using the processor function. You can get the table using the :get() method: local data = { red = \"foo\" , blue = \"bar\" } local renamed = ForKeys ( data , function ( key ) return string.upper ( key ) end ) print ( renamed : get ()) --> {RED = \"foo\", BLUE = \"bar\"}","title":"Basic Usage"},{"location":"tutorials/lists-and-tables/forkeys/#state-objects","text":"The input table can be provided as a state object instead, and the output table will update as the input table is changed: local playerSet = Value ({}) local userIdSet = ForKeys ( playerSet , function ( player ) return player . UserId end ) playerSet : set ({ [ Players . Elttob ] = true }) print ( userIdSet : get ()) --> {[1670764] = true} playerSet : set ({ [ Players . boatbomber ] = true , [ Players . EgoMoose ] = true }) print ( userIdSet : get ()) --> {[33655127] = true, [2155311] = true} Additionally, you can use state objects in your calculations, just like a computed: local playerSet = { [ Players . boatbomber ] = true , [ Players . EgoMoose ] = true } local prefix = Value ( \"User_\" ) local userIdSet = ForKeys ( playerSet , function ( player ) return prefix .. player . UserId end ) print ( userIdSet : get ()) --> {User_33655127 = true, User_2155311 = true} prefix : set ( \"player\" ) print ( userIdSet : get ()) --> {player33655127 = true, player2155311 = true}","title":"State Objects"},{"location":"tutorials/lists-and-tables/forkeys/#cleanup-behaviour","text":"By default, ForKeys will clean up any returned keys that get removed, using the same rules as Cleanup . See the cleanup rules here. local eventSet = Value ({ [ RunService . RenderStepped ] = true , [ RunService . Heartbeat ] = true }) local connectionSet = ForKeys ( eventSet , function ( event ) -- make a new connection for each event return event : Connect ( function (...) print ( event , \"fired with arguments:\" , ...) end ) end ) -- remove Heartbeat from the event set -- this will :Disconnect() the Heartbeat connection automatically eventSet : set ({ [ RunService . RenderStepped ] = true }) If you want to run your own code when values are removed instead, you can pass in a second 'destructor' function: local eventSet = Value ({ [ RunService . RenderStepped ] = true , [ RunService . Heartbeat ] = true }) local connectionSet = ForKeys ( eventSet , -- processor function ( event ) local eventName = tostring ( event ) local connection = event : Connect ( function (...) print ( eventName , \"fired with arguments:\" , ...) end ) return connection end , -- destructor function ( connection ) print ( \"Disconnecting the event!\" ) connection : Disconnect () -- don't forget we're overriding the default cleanup end ) -- remove Heartbeat from the event set -- this will run our destructor with the Heartbeat connection eventSet : set ({ [ RunService . RenderStepped ] = true }) --> Disconnecting the event! When using a custom destructor, you can send one extra return value to your destructor without including it in the output table: local eventSet = Value ({ [ RunService . RenderStepped ] = true , [ RunService . Heartbeat ] = true }) local connectionSet = ForKeys ( eventSet , -- processor function ( event ) local eventName = tostring ( event ) local connection = event : Connect ( function (...) print ( eventName , \"fired with arguments:\" , ...) end ) return connection , eventName end , -- destructor function ( connection , eventName ) print ( \"Disconnecting \" .. eventName .. \"!\" ) connection : Disconnect () end ) eventSet : set ({ [ RunService . RenderStepped ] = true }) --> Disconnecting Signal Heartbeat!","title":"Cleanup Behaviour"},{"location":"tutorials/lists-and-tables/forkeys/#optimisations","text":"Optional You don't have to memorise these optimisations to use ForKeys , but it can be helpful if you have a performance problem. Rather than creating a new output table from scratch every time the input table is changed, ForKeys will try and reuse as much as possible to improve performance. For example, let's say we're converting an array to a dictionary: local array = Value ({ \"Fusion\" , \"Knit\" , \"Matter\" }) local dict = ForKeys ( array , function ( index ) return \"Value\" .. index end ) print ( dict : get ()) --> {Value1 = \"Fusion\", Value2 = \"Knit\", Value3 = \"Matter\"} Because ForKeys only operates on the keys, changing the values in the array doesn't affect the keys. Keys are only added or removed as needed: local array = Value ({ \"Fusion\" , \"Knit\" , \"Matter\" }) local dict = ForKeys ( array , function ( index ) return \"Value\" .. index end ) print ( dict : get ()) --> {Value1 = \"Fusion\", Value2 = \"Knit\", Value3 = \"Matter\"} array : set ({ \"Roact\" , \"Rodux\" }) print ( dict : get ()) --> {Value1 = \"Roact\", Value2 = \"Rodux\"} ForKeys takes advantage of this - when a value changes, it's copied into the output table without recalculating the key. Keys are only calculated when a value is assigned to a new key.","title":"Optimisations"},{"location":"tutorials/lists-and-tables/forpairs/","text":"ForPairs combines the functions of ForValues and ForKeys into one object. It can process pairs of keys and values at the same time. The input table can be a state object, and the output values can use state objects. local itemColours = { shoes = \"red\" , socks = \"blue\" } local owner = Value ( \"Elttob\" ) local manipulated = ForPairs ( itemColours , function ( thing , colour ) local newKey = colour local newValue = owner : get () .. \"'s \" .. thing return newKey , newValue end ) print ( manipulated : get ()) --> {red = \"Elttob's shoes\", blue = \"Elttob's socks\"} owner : set ( \"Quenty\" ) print ( manipulated : get ()) --> {red = \"Quenty's shoes\", blue = \"Quenty's socks\"} Usage \u00b6 To use ForPairs in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local ForPairs = Fusion . ForPairs Basic Usage \u00b6 To create a new ForPairs object, call the constructor with an input table and a processor function: local itemColours = { shoes = \"red\" , socks = \"blue\" } local swapped = ForPairs ( data , function ( key , value ) return value , key end ) This will generate a new table, where each key-value pair is replaced using the processor function. You can get the table using the :get() method: local itemColours = { shoes = \"red\" , socks = \"blue\" } local swapped = ForPairs ( data , function ( key , value ) return value , key end ) print ( swapped : get ()) --> {red = \"shoes\", blue = \"socks\"} State Objects \u00b6 As with ForKeys and ForValues , the input table can be provided as a state object, and the processor function can use other state objects in its calculations. See the ForValues page for examples. Cleanup Behaviour \u00b6 Similar to ForValues and ForKeys , ForPairs will clean up any returned keys and values that get removed, using the same rules as Cleanup . See the cleanup rules here. Also similarly, you may pass in a 'destructor' function to override this behaviour, and send your own metadata to it: local watchedInstances = Value ({ [ workspace . Part1 ] = \"One\" , [ workspace . Part2 ] = \"Two\" , [ workspace . Part3 ] = \"Three\" }) local connectionSet = ForPairs ( eventSet , -- processor function ( instance , displayName ) local metadata = { displayName = displayName , numChanges = 0 } local connection = instance . Changed : Connect ( function () print ( \"Instance\" , displayName , \"was changed!\" ) metadata . numChanges += 1 end ) return instance , connection , metadata end , -- destructor function ( instance , connection , metadata ) print ( \"Removing\" , metadata . displayName , \"after\" , metadata . numChanges , \"changes\" ) connection : Disconnect () -- don't forget we're overriding the default cleanup end ) -- remove Part3 from the input table -- this will run our destructor with Part3, it's Changed event, and our metadata watchedInstances : set ({ [ workspace . Part1 ] = \"One\" , [ workspace . Part2 ] = \"Two\" }) Optimisations \u00b6 Optional You don't have to memorise these optimisations to use ForPairs , but it can be helpful if you have a performance problem. Rather than creating a new output table from scratch every time the input table is changed, ForPairs will try and reuse as much as possible to improve performance. Since ForPairs has to depend on both keys and values, changing any value in the input table will cause a recalculation for that key-value pair. Inversely, ForPairs won't recalculate any key-value pairs that stay the same. Instead, these will be preserved in the output table. If you don't need the keys or the values, Fusion can offer better optimisations. For example, if you're working with an array of values where position doesn't matter, ForValues can move values between keys. Alternatively, if you're working with a set of objects stored in keys, and don't need the values in the table, ForKeys will ignore the values for optimal performance.","title":"ForPairs"},{"location":"tutorials/lists-and-tables/forpairs/#usage","text":"To use ForPairs in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local ForPairs = Fusion . ForPairs","title":"Usage"},{"location":"tutorials/lists-and-tables/forpairs/#basic-usage","text":"To create a new ForPairs object, call the constructor with an input table and a processor function: local itemColours = { shoes = \"red\" , socks = \"blue\" } local swapped = ForPairs ( data , function ( key , value ) return value , key end ) This will generate a new table, where each key-value pair is replaced using the processor function. You can get the table using the :get() method: local itemColours = { shoes = \"red\" , socks = \"blue\" } local swapped = ForPairs ( data , function ( key , value ) return value , key end ) print ( swapped : get ()) --> {red = \"shoes\", blue = \"socks\"}","title":"Basic Usage"},{"location":"tutorials/lists-and-tables/forpairs/#state-objects","text":"As with ForKeys and ForValues , the input table can be provided as a state object, and the processor function can use other state objects in its calculations. See the ForValues page for examples.","title":"State Objects"},{"location":"tutorials/lists-and-tables/forpairs/#cleanup-behaviour","text":"Similar to ForValues and ForKeys , ForPairs will clean up any returned keys and values that get removed, using the same rules as Cleanup . See the cleanup rules here. Also similarly, you may pass in a 'destructor' function to override this behaviour, and send your own metadata to it: local watchedInstances = Value ({ [ workspace . Part1 ] = \"One\" , [ workspace . Part2 ] = \"Two\" , [ workspace . Part3 ] = \"Three\" }) local connectionSet = ForPairs ( eventSet , -- processor function ( instance , displayName ) local metadata = { displayName = displayName , numChanges = 0 } local connection = instance . Changed : Connect ( function () print ( \"Instance\" , displayName , \"was changed!\" ) metadata . numChanges += 1 end ) return instance , connection , metadata end , -- destructor function ( instance , connection , metadata ) print ( \"Removing\" , metadata . displayName , \"after\" , metadata . numChanges , \"changes\" ) connection : Disconnect () -- don't forget we're overriding the default cleanup end ) -- remove Part3 from the input table -- this will run our destructor with Part3, it's Changed event, and our metadata watchedInstances : set ({ [ workspace . Part1 ] = \"One\" , [ workspace . Part2 ] = \"Two\" })","title":"Cleanup Behaviour"},{"location":"tutorials/lists-and-tables/forpairs/#optimisations","text":"Optional You don't have to memorise these optimisations to use ForPairs , but it can be helpful if you have a performance problem. Rather than creating a new output table from scratch every time the input table is changed, ForPairs will try and reuse as much as possible to improve performance. Since ForPairs has to depend on both keys and values, changing any value in the input table will cause a recalculation for that key-value pair. Inversely, ForPairs won't recalculate any key-value pairs that stay the same. Instead, these will be preserved in the output table. If you don't need the keys or the values, Fusion can offer better optimisations. For example, if you're working with an array of values where position doesn't matter, ForValues can move values between keys. Alternatively, if you're working with a set of objects stored in keys, and don't need the values in the table, ForKeys will ignore the values for optimal performance.","title":"Optimisations"},{"location":"tutorials/lists-and-tables/forvalues/","text":"ForValues is a state object that creates a new table by processing values from another table. The input table can be a state object, and the output values can use state objects. local numbers = { 1 , 2 , 3 , 4 , 5 } local multiplier = Value ( 2 ) local multiplied = ForValues ( numbers , function ( num ) return num * multiplier : get () end ) print ( multiplied : get ()) --> {2, 4, 6, 8, 10} multiplier : set ( 10 ) print ( multiplied : get ()) --> {10, 20, 30, 40, 50} Usage \u00b6 To use ForValues in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local ForValues = Fusion . ForValues Basic Usage \u00b6 To create a new ForValues object, call the constructor with an input table and a processor function: local numbers = { 1 , 2 , 3 , 4 , 5 } local doubled = ForValues ( numbers , function ( num ) return num * 2 end ) This will generate a new table of values, where each value is passed through the processor function. You can get the table using the :get() method: local numbers = { 1 , 2 , 3 , 4 , 5 } local doubled = ForValues ( numbers , function ( num ) return num * 2 end ) print ( doubled : get ()) --> {2, 4, 6, 8, 10} State Objects \u00b6 The input table can be provided as a state object instead, and the output table will update as the input table is changed: local numbers = Value ({}) local doubled = ForValues ( numbers , function ( num ) return num * 2 end ) numbers : set ({ 1 , 2 , 3 , 4 , 5 }) print ( doubled : get ()) --> {2, 4, 6, 8, 10} numbers : set ({ 5 , 15 , 25 }) print ( doubled : get ()) --> {10, 30, 50} Additionally, you can use state objects in your calculations, just like a computed: local numbers = { 1 , 2 , 3 , 4 , 5 } local factor = Value ( 2 ) local multiplied = ForValues ( numbers , function ( num ) return num * factor : get () end ) print ( multiplied : get ()) --> {2, 4, 6, 8, 10} factor : set ( 10 ) print ( multiplied : get ()) --> {10, 20, 30, 40, 50} Cleanup Behaviour \u00b6 By default, ForValues will clean up any values that get removed, using the same rules as Cleanup . See the cleanup rules here. local names = Value ({ \"Jodi\" , \"Amber\" , \"Umair\" }) local textLabels = ForValues ( names , function ( name ) -- return a TextLabel instance for every name return New \"TextLabel\" { Text = name } end ) -- remove Jodi from the names list -- this will :Destroy() Jodi's TextLabel names : set ({ \"Amber\" , \"Umair\" }) If you want to run your own code when values are removed instead, you can pass in a second 'destructor' function: local names = Value ({ \"Jodi\" , \"Amber\" , \"Umair\" }) local textLabels = ForValues ( names , -- processor function ( name ) return New \"TextLabel\" { Text = name } end , -- destructor function ( textLabel ) print ( \"Destructor got text label:\" , textLabel . Text ) textLabel : Destroy () -- don't forget we're overriding the default cleanup end ) -- remove Jodi from the names list -- this will run our destructor with Jodi's TextLabel names : set ({ \"Amber\" , \"Umair\" }) --> Destructor got text label: Jodi When using a custom destructor, you can send one extra return value to your destructor without including it in the output table: local names = Value ({ \"Jodi\" , \"Amber\" , \"Umair\" }) local textLabels = ForValues ( names , -- processor function ( name ) local textLabel = New \"TextLabel\" { Text = name } local uppercased = name : upper () -- `textLabel` will be included in the output table -- `uppercased` is not included, but still passed to the destructor return textLabel , uppercased end , -- destructor function ( textLabel , uppercased ) print ( \"Destructor got uppercased:\" , uppercased ) textLabel : Destroy () end ) names : set ({ \"Amber\" , \"Umair\" }) --> Destructor got uppercased: JODI Optimisations \u00b6 Optional You don't have to memorise these optimisations to use ForValues , but it can be helpful if you have a performance problem. Rather than creating a new output table from scratch every time the input table is changed, ForValues will try and reuse as much as possible to improve performance. For example, let's say we're measuring the lengths of an array of words: local words = Value ({ \"Orange\" , \"Red\" , \"Magenta\" }) local lengths = ForValues ( words , function ( word ) return # word end ) print ( lengths : get ()) --> {6, 3, 7} The word lengths don't depend on the position of the word in the array. This means that rearranging the words in the input array will just rearrange the lengths in the output array: ForValues takes advantage of this - when input values move around, the output values will move around too, instead of being recalculated. Note that values are only reused once. For example, if we added another occurence of 'Orange', our calculation would have to run again for the second 'Orange':","title":"ForValues"},{"location":"tutorials/lists-and-tables/forvalues/#usage","text":"To use ForValues in your code, you first need to import it from the Fusion module, so that you can refer to it by name: 1 2 local Fusion = require ( ReplicatedStorage . Fusion ) local ForValues = Fusion . ForValues","title":"Usage"},{"location":"tutorials/lists-and-tables/forvalues/#basic-usage","text":"To create a new ForValues object, call the constructor with an input table and a processor function: local numbers = { 1 , 2 , 3 , 4 , 5 } local doubled = ForValues ( numbers , function ( num ) return num * 2 end ) This will generate a new table of values, where each value is passed through the processor function. You can get the table using the :get() method: local numbers = { 1 , 2 , 3 , 4 , 5 } local doubled = ForValues ( numbers , function ( num ) return num * 2 end ) print ( doubled : get ()) --> {2, 4, 6, 8, 10}","title":"Basic Usage"},{"location":"tutorials/lists-and-tables/forvalues/#state-objects","text":"The input table can be provided as a state object instead, and the output table will update as the input table is changed: local numbers = Value ({}) local doubled = ForValues ( numbers , function ( num ) return num * 2 end ) numbers : set ({ 1 , 2 , 3 , 4 , 5 }) print ( doubled : get ()) --> {2, 4, 6, 8, 10} numbers : set ({ 5 , 15 , 25 }) print ( doubled : get ()) --> {10, 30, 50} Additionally, you can use state objects in your calculations, just like a computed: local numbers = { 1 , 2 , 3 , 4 , 5 } local factor = Value ( 2 ) local multiplied = ForValues ( numbers , function ( num ) return num * factor : get () end ) print ( multiplied : get ()) --> {2, 4, 6, 8, 10} factor : set ( 10 ) print ( multiplied : get ()) --> {10, 20, 30, 40, 50}","title":"State Objects"},{"location":"tutorials/lists-and-tables/forvalues/#cleanup-behaviour","text":"By default, ForValues will clean up any values that get removed, using the same rules as Cleanup . See the cleanup rules here. local names = Value ({ \"Jodi\" , \"Amber\" , \"Umair\" }) local textLabels = ForValues ( names , function ( name ) -- return a TextLabel instance for every name return New \"TextLabel\" { Text = name } end ) -- remove Jodi from the names list -- this will :Destroy() Jodi's TextLabel names : set ({ \"Amber\" , \"Umair\" }) If you want to run your own code when values are removed instead, you can pass in a second 'destructor' function: local names = Value ({ \"Jodi\" , \"Amber\" , \"Umair\" }) local textLabels = ForValues ( names , -- processor function ( name ) return New \"TextLabel\" { Text = name } end , -- destructor function ( textLabel ) print ( \"Destructor got text label:\" , textLabel . Text ) textLabel : Destroy () -- don't forget we're overriding the default cleanup end ) -- remove Jodi from the names list -- this will run our destructor with Jodi's TextLabel names : set ({ \"Amber\" , \"Umair\" }) --> Destructor got text label: Jodi When using a custom destructor, you can send one extra return value to your destructor without including it in the output table: local names = Value ({ \"Jodi\" , \"Amber\" , \"Umair\" }) local textLabels = ForValues ( names , -- processor function ( name ) local textLabel = New \"TextLabel\" { Text = name } local uppercased = name : upper () -- `textLabel` will be included in the output table -- `uppercased` is not included, but still passed to the destructor return textLabel , uppercased end , -- destructor function ( textLabel , uppercased ) print ( \"Destructor got uppercased:\" , uppercased ) textLabel : Destroy () end ) names : set ({ \"Amber\" , \"Umair\" }) --> Destructor got uppercased: JODI","title":"Cleanup Behaviour"},{"location":"tutorials/lists-and-tables/forvalues/#optimisations","text":"Optional You don't have to memorise these optimisations to use ForValues , but it can be helpful if you have a performance problem. Rather than creating a new output table from scratch every time the input table is changed, ForValues will try and reuse as much as possible to improve performance. For example, let's say we're measuring the lengths of an array of words: local words = Value ({ \"Orange\" , \"Red\" , \"Magenta\" }) local lengths = ForValues ( words , function ( word ) return # word end ) print ( lengths : get ()) --> {6, 3, 7} The word lengths don't depend on the position of the word in the array. This means that rearranging the words in the input array will just rearrange the lengths in the output array: ForValues takes advantage of this - when input values move around, the output values will move around too, instead of being recalculated. Note that values are only reused once. For example, if we added another occurence of 'Orange', our calculation would have to run again for the second 'Orange':","title":"Optimisations"},{"location":"tutorials/lists-and-tables/the-for-objects/","text":"Often when building UI, we need to deal with lists, arrays and tables. For example: creating an array of TextLabels for a player list generating a settings page from pairs of keys and values in a configuration filling a grid with inventory slots and items Most of these use cases involve processing one table into another: converting an array of player names into an array of TextLabels converting a table of settings into a table of UI controls converting an array of inventory items into an array of slot UIs So, to assist with these use cases, Fusion has a few state objects which are specially designed for working with arrays and tables. These are known as the For objects. The Problem \u00b6 To start, let's try making a player list using our regular state objects from before. We'll define an array of player names and some basic UI to place it in: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 local playerNames = Value ({ \"Elttob\" , \"boatbomber\" , \"thisfall\" , \"AxisAngles\" }) local textLabels = {} -- TODO: implement this local ui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , [ Children ] = New \"Frame\" { Name = \"PlayerList\" , Position = UDim2 . fromScale ( 1 , 1 ), AnchorPoint = Vector2 . new ( 1 , 0 ), Size = UDim2 . fromOffset ( 200 , 0 ), AutomaticSize = \"Y\" , [ Children ] = { New \"UIListLayout\" { SortOrder = \"Name\" }, textLabels } } } Now, let's make a Computed which generates our text labels for us: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 local playerNames = Value ({ \"Elttob\" , \"boatbomber\" , \"thisfall\" , \"AxisAngles\" }) local textLabels = Computed ( function () local out = {} for index , playerName in playerNames : get () do out [ index ] = New \"TextLabel\" { Name = playerName , Size = UDim2 . new ( 1 , 0 , 0 , 50 ), Text = playerName } end return out end ) local ui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , This is alright, but there are a few problems: Firstly, there's a fair amount of boilerplate - in order to generate our list of text labels, we have to create a Computed , initialise a new table, write a for-loop to populate the table, then return it. Boilerplate is generally annoying, and especially so for a task as common as dealing with lists and tables. It's less clear to read and more tedious to write. Secondly, whenever playerNames is changed, we reconstruct the entire list, destroying all of our instances and any data associated with them. This is both inefficient and also causes issues with data loss. Ideally, we should only be modifying the text labels for players that have joined or left, leaving the rest of the text labels alone. To address this shortcoming, the For objects provide a cleaner way to do the same thing, except with less boilerplate and leaving unchanged values alone: 1 2 3 4 5 6 7 8 9 10 11 12 local playerNames = Value ({ \"Elttob\" , \"boatbomber\" , \"thisfall\" , \"AxisAngles\" }) local textLabels = ForValues ( playerNames , function () return New \"TextLabel\" { Name = playerName , Size = UDim2 . new ( 1 , 0 , 0 , 50 ), Text = playerName } end ) local ui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Over the next few pages, we'll take a look at three state objects: ForValues , which lets you process just the values in a table. ForKeys , which lets you process just the keys in a table. ForPairs , which lets you do both at the same time.","title":"The For Objects"},{"location":"tutorials/lists-and-tables/the-for-objects/#the-problem","text":"To start, let's try making a player list using our regular state objects from before. We'll define an array of player names and some basic UI to place it in: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 local playerNames = Value ({ \"Elttob\" , \"boatbomber\" , \"thisfall\" , \"AxisAngles\" }) local textLabels = {} -- TODO: implement this local ui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , [ Children ] = New \"Frame\" { Name = \"PlayerList\" , Position = UDim2 . fromScale ( 1 , 1 ), AnchorPoint = Vector2 . new ( 1 , 0 ), Size = UDim2 . fromOffset ( 200 , 0 ), AutomaticSize = \"Y\" , [ Children ] = { New \"UIListLayout\" { SortOrder = \"Name\" }, textLabels } } } Now, let's make a Computed which generates our text labels for us: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 local playerNames = Value ({ \"Elttob\" , \"boatbomber\" , \"thisfall\" , \"AxisAngles\" }) local textLabels = Computed ( function () local out = {} for index , playerName in playerNames : get () do out [ index ] = New \"TextLabel\" { Name = playerName , Size = UDim2 . new ( 1 , 0 , 0 , 50 ), Text = playerName } end return out end ) local ui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , This is alright, but there are a few problems: Firstly, there's a fair amount of boilerplate - in order to generate our list of text labels, we have to create a Computed , initialise a new table, write a for-loop to populate the table, then return it. Boilerplate is generally annoying, and especially so for a task as common as dealing with lists and tables. It's less clear to read and more tedious to write. Secondly, whenever playerNames is changed, we reconstruct the entire list, destroying all of our instances and any data associated with them. This is both inefficient and also causes issues with data loss. Ideally, we should only be modifying the text labels for players that have joined or left, leaving the rest of the text labels alone. To address this shortcoming, the For objects provide a cleaner way to do the same thing, except with less boilerplate and leaving unchanged values alone: 1 2 3 4 5 6 7 8 9 10 11 12 local playerNames = Value ({ \"Elttob\" , \"boatbomber\" , \"thisfall\" , \"AxisAngles\" }) local textLabels = ForValues ( playerNames , function () return New \"TextLabel\" { Name = playerName , Size = UDim2 . new ( 1 , 0 , 0 , 50 ), Text = playerName } end ) local ui = New \"ScreenGui\" { Parent = Players . LocalPlayer . PlayerGui , Over the next few pages, we'll take a look at three state objects: ForValues , which lets you process just the values in a table. ForKeys , which lets you process just the keys in a table. ForPairs , which lets you do both at the same time.","title":"The Problem"}]}